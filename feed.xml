<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-04-01T15:02:19+08:00</updated><id>/</id><subtitle>Dark knight's的个人技术博客,专注于web开发,追求前端最完美体验</subtitle><entry><title type="html">JavaScript内置对象之数组</title><link href="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/" rel="alternate" type="text/html" title="JavaScript内置对象之数组" /><published>2019-11-12T00:00:00+08:00</published><updated>2019-11-12T00:00:00+08:00</updated><id>/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array</id><content type="html" xml:base="/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2019/11/12/js-array/">&lt;p&gt;本文为了详细记录JavaScript内置对象中的一些方法&lt;/p&gt;</content><author><name>toshiba</name></author><category term="javascript" /><summary type="html">本文为了详细记录JavaScript内置对象中的一些方法</summary></entry><entry><title type="html">在浏览器输入 URL 回车之后发生了什么</title><link href="/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all/" rel="alternate" type="text/html" title="在浏览器输入 URL 回车之后发生了什么" /><published>2019-09-16T00:00:00+08:00</published><updated>2019-09-16T00:00:00+08:00</updated><id>/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all</id><content type="html" xml:base="/%E9%9D%A2%E8%AF%95/2019/09/16/browser-input-all/">&lt;p&gt;不久前看了一篇文章&lt;a href=&quot;https://4ark.me/post/b6c7c0a2.html&quot;&gt;在浏览器输入 URL 回车之后发生了什么&lt;/a&gt;, 感觉讲的实在很好所以在此我也想总结一下,当自己被问到这个问题的时候会如何回答呢?&lt;/p&gt;

&lt;p&gt;在浏览器输入 URL 回车之后发生了什么？
大致流程如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.URL解析&lt;/li&gt;
  &lt;li&gt;2.DNS查询；&lt;/li&gt;
  &lt;li&gt;3.建立TCP连接；&lt;/li&gt;
  &lt;li&gt;4.发送HTTP请求；&lt;/li&gt;
  &lt;li&gt;5.服务器处理请求；&lt;/li&gt;
  &lt;li&gt;6.返回响应结果；&lt;/li&gt;
  &lt;li&gt;7.关闭TCP连接；&lt;/li&gt;
  &lt;li&gt;8.浏览器解析HTML；&lt;/li&gt;
  &lt;li&gt;9.浏览器布局渲染；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们在浏览器输入网址回车后,一切从这里开始&lt;/p&gt;
&lt;h3 id=&quot;url解析&quot;&gt;URL解析&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;HSTS(HTTP Strict Transport Security), 强制客户端使用 HTTPS 访问页面&lt;/code&gt;,&lt;a href=&quot;https://www.barretlee.com/blog/2015/10/22/hsts-intro/&quot;&gt;你不知道的HSTS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先判断你输入的是一个合法的URL还是一个带搜索的关键词&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果输入的是内容则将输入内容自动编码。&lt;/li&gt;
  &lt;li&gt;输入的是网址向服务器请求我们想要的页面内容则开始进行DNS域名查询&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浏览器需要首先确认的是域名所对应的服务器在哪里,将域名解析成对应的服务器IP地址这项工作,是由DNS服务器来完成的.
客户端收到你输入的域名地址后,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.首先会从浏览器缓存中查找是否有对应域名&lt;/li&gt;
  &lt;li&gt;2.操作系统缓存&lt;/li&gt;
  &lt;li&gt;3.路由器DNS缓存&lt;/li&gt;
  &lt;li&gt;4.查找本地的hosts文件&lt;/li&gt;
  &lt;li&gt;5.ISP的DNS服务器&lt;/li&gt;
  &lt;li&gt;6.根域名服务器 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8&quot;&gt;维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;ISP&lt;/code&gt;是&lt;code&gt;Internet Service Provider(因特网服务提供商)&lt;/code&gt;的简称,ISP有专门的DNS服务器应对DNS查询请求.每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，依次类推）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;根域名服务器查询&quot;&gt;根域名服务器查询&lt;/h4&gt;
&lt;p&gt;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/search.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）&lt;/li&gt;
  &lt;li&gt;迭代方式，就是本地DNS服务器到根域名服务器查询的方式。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran&quot;&gt;什么是 DNS 劫持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50043595&quot;&gt;前端 dns-prefetch 优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;递归查询：
    主机向本地域名服务器的查询一般都是采用递归查询。
    如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址&lt;/p&gt;

&lt;p&gt;迭代查询：
    本地域名服务器向根域名服务器的查询通常是采用迭代查询。
    当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。&lt;/p&gt;

&lt;h3 id=&quot;tcp连接&quot;&gt;TCP连接&lt;/h3&gt;
&lt;p&gt;TCP/IP 分四层,在发送数据时,每层都要对数据进行封装&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/tcp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;应用层发送http请求&quot;&gt;应用层:发送HTTP请求&lt;/h4&gt;

&lt;p&gt;在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;请求报头（Request Header）：请求方法、目标地址、遵循的协议等等&lt;/li&gt;
  &lt;li&gt;请求主体（其他参数）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中需要注意的点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;传输层-tcp传输报文&quot;&gt;传输层: TCP传输报文&lt;/h4&gt;
&lt;p&gt;传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。&lt;/p&gt;

&lt;p&gt;在建立连接前，会先进行 TCP 三次握手。&lt;a href=&quot;https://github.com/jawil/blog/issues/14&quot;&gt;通俗解释TCP协议三次握手&lt;/a&gt;、&lt;a href=&quot;https://hit-alibaba.github.io/interview/basic/network/HTTP.html&quot;&gt;计算机网络&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/cpcpcp123/article/details/52739407&quot;&gt;SYN 泛洪攻击&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;网络层-ip协议查询mac地址&quot;&gt;网络层: IP协议查询Mac地址&lt;/h4&gt;
&lt;p&gt;将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。
判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP 协议&lt;/a&gt;查询它的 Mac 地址。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;注意：在 OSI 参考模型中 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP&lt;/a&gt; 协议位于链路层，但在 TCP/IP 中，它位于网络层。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;链路层-以太网协议&quot;&gt;链路层: 以太网协议&lt;/h4&gt;

&lt;p&gt;根据以太网协议将数据分为以”帧”为单位的数据包, 每一帧分为两个部分:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标头: 数据包的发送者、接受者、数据类型&lt;/li&gt;
  &lt;li&gt;数据: 数据包具体内容&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mac地址
以太网规定了连入网络的所有设备都必须具备“网卡”接口, 数据包都是从一块网卡传递到另一块网卡,网卡地址就是Mac地址.每一个Mac地址都是独一无二的,具备了一对一的能力.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;广播
发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。 但是接受方回应是单播.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;服务器接受请求&quot;&gt;服务器接受请求&lt;/h4&gt;

&lt;h3 id=&quot;服务器处理请求&quot;&gt;服务器处理请求&lt;/h3&gt;

&lt;h4 id=&quot;httpd&quot;&gt;HTTPD&lt;/h4&gt;
&lt;p&gt;最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。
它会监听得到的请求，然后开启一个子进程去处理这个请求。&lt;/p&gt;

&lt;h4 id=&quot;处理请求&quot;&gt;处理请求&lt;/h4&gt;
&lt;p&gt;接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;验证是否配置虚拟主机&lt;/li&gt;
  &lt;li&gt;验证虚拟主机是否接受此方法&lt;/li&gt;
  &lt;li&gt;验证该用户可以使用该方法（根据 IP 地址、身份信息等）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;url重写&quot;&gt;URL重写&lt;/h4&gt;
&lt;p&gt;然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。&lt;/p&gt;

&lt;p&gt;否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。&lt;/p&gt;

&lt;p&gt;然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。&lt;/p&gt;

&lt;p&gt;以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。&lt;/p&gt;

&lt;h3 id=&quot;浏览器接受响应&quot;&gt;浏览器接受响应&lt;/h3&gt;
&lt;p&gt;浏览器接收到来自服务器的响应资源后，会对资源进行分析。&lt;/p&gt;

&lt;p&gt;首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。&lt;/p&gt;

&lt;p&gt;如果响应资源进行了压缩（比如 gzip），还需要进行解压。&lt;/p&gt;

&lt;p&gt;然后，对响应资源做缓存。&lt;/p&gt;

&lt;p&gt;接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。&lt;/p&gt;

&lt;h3 id=&quot;渲染页面&quot;&gt;渲染页面&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/core.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/browser-input/process.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;文章参考&quot;&gt;文章参考&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://hellogithub2014.github.io/2017/09/24/how-do-network-connect/&quot;&gt;从浏览器输入url按回车后发生了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50043595&quot;&gt;浏览器探究&amp;amp;前端优化指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28771785&quot;&gt;ARP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bisend.cn/blog/dns-ji-chi-yu-wu-ran&quot;&gt;什么是DNS劫持与DNS污染&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/59ba146c6fb9a00a4636d8b6&quot;&gt;深入理解Http请求、DNS劫持与解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/it_rod/article/details/79939651&quot;&gt;HTTP基础与DNS分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/gopark/p/8430916.html&quot;&gt;DNS原理及其解析过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://4ark.me/post/b6c7c0a2.html&quot;&gt;在浏览器输入 URL 回车之后发生了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xsilence/&quot;&gt;DNS查找域名的过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://fex.baidu.com/blog/2014/05/what-happen/&quot;&gt;从输入 URL 到页面加载完成的过程中都发生了什么事情？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="基础" /><category term="面试" /><category term="HSTS" /><summary type="html">不久前看了一篇文章在浏览器输入 URL 回车之后发生了什么, 感觉讲的实在很好所以在此我也想总结一下,当自己被问到这个问题的时候会如何回答呢?</summary></entry><entry><title type="html">LeetCode刷题总结(简单版五)</title><link href="/leetcode/2019/09/08/leetcode-five/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版五)" /><published>2019-09-08T00:00:00+08:00</published><updated>2019-09-08T00:00:00+08:00</updated><id>/leetcode/2019/09/08/leetcode-five</id><content type="html" xml:base="/leetcode/2019/09/08/leetcode-five/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1两个数组的交集&quot;&gt;1.两个数组的交集&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-arrays/&quot;&gt;两个数组的交集&lt;/a&gt;：
给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [9,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输出结果中的每个元素一定是唯一的。&lt;/li&gt;
  &lt;li&gt;我们可以不考虑输出结果的顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;自己的解法常规思路不推荐&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    
    let resultDup = [];
    nums1.forEach(val =&amp;gt; {
        nums2.forEach(v =&amp;gt; {
            if(val == v) {
                resultDup.push(val);
            }
        })
    });
    
    let result = [];
    while(resultDup.length &amp;gt; 0) {
        let val = resultDup.shift();
        if(resultDup.indexOf(val) &amp;lt; 0) {
            result.push(val);    
        }
    }

    return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样js解法利用Set去重复&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var intersection = function(nums1, nums2) {
    let hash1 = new Set(nums1)
    let hash2 = new Set()

    for(let i = 0; i &amp;lt; nums.length; i++) {
        if(has1.has(nums2[i])) {
            hash2.add(nums2[i])
        }
    }
    return [...hash2]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用数组api解法,更简洁&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var intersection = function(nums1, nums2) {
    return [...new Set(nums1.filter(v =&amp;gt; nums2.includes(v)))];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; class Solution {
     public int[] intersection(int[] nums1, int[] nums2) {
         HashSet&amp;lt;Integer&amp;gt; set1 = new HashSet&amp;lt;Integer&amp;gt;();
         for(Integer n : nums1) set1.add(n);

         HashSet&amp;lt;Integer&amp;gt; set2 = new HashSet&amp;lt;Integer&amp;gt;();
         for(Integer n : nums2) set2.add(n);

         set1.retainAll(set2);

         int[] output = new int[set1.size()];
         int idx = 0;
         for(int s : set) output[idx++] = s;
         return output;

     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2独一无二的出现次数&quot;&gt;2.独一无二的出现次数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-number-of-occurrences/&quot;&gt;独一无二的出现次数&lt;/a&gt;: 
 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。&lt;/p&gt;

&lt;p&gt;如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 1000&lt;/li&gt;
  &lt;li&gt;-1000 &amp;lt;= arr[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
示例 2：

输入：arr = [1,2]
输出：false
示例 3：

输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var uniqueOccurrences = function(arr) {
    let objMap = {}
    
    arr.forEach(val =&amp;gt; {
        if(objMap.hasOwnProperty(val)) {
            objMap[val]++;
        } else {
            objMap[val] = 1;
        }
    })
    
    let arr1 = Object.values(objMap);
    let arr2 = [...new Set(arr1)];
    
    return arr1.length === arr2.length;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        Set&amp;lt;Inetger&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();

        for(int data: arr) {
            if(map.get(data) == null) map.put(data,1);
            else map.put(data, map.get(data) + 1);
        }

        for(Integer i : map.values()) {
            if(!set.add(i)) return false;
        }

        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3转置矩阵&quot;&gt;3.转置矩阵&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/transpose-matrix/submissions/&quot;&gt;转置矩阵&lt;/a&gt;: 
给定一个矩阵 A， 返回 A 的转置矩阵。&lt;/p&gt;

&lt;p&gt;矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 1000&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= A[0].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
示例 2：

输入：[[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var transpose = function(A) {
    let len = A[0].length;
    let alen = A.length;
    let result = [];
    
    for(let i = 0; i &amp;lt; len; i++) {
        let tmpl = [];
        A.forEach((val, idex) =&amp;gt; {
            tmpl.push(val[i]);
        });
        result.push(tmpl);
    }
    
   return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4重复-n-次的元素&quot;&gt;4.重复 N 次的元素&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/submissions/&quot;&gt;重复 N 次的元素&lt;/a&gt;:
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。&lt;/p&gt;

&lt;p&gt;返回重复了 N 次的那个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[1,2,3,3]
输出：3
示例 2：

输入：[2,1,2,5,3,2]
输出：2
示例 3：

输入：[5,1,5,2,5,3,5,4]
输出：5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt; 10000&lt;/li&gt;
  &lt;li&gt;A.length 为偶数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} A
 * @return {number}
 */
var repeatedNTimes = function(A) {
    A.sort((a, b) =&amp;gt; a-b);
    let len = A.length;
    let result = 0;
    for(let i = 0; i &amp;lt; len; i++) {
        if(i &amp;gt; 0) {
            let cur = A[i]
            let prev = A[i - 1];
            if(cur - prev === 0) {
                result = cur;
                break;
            }
        }
    }
    return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5按奇偶排序数组-ii&quot;&gt;5.按奇偶排序数组 II&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-array-by-parity-ii/&quot;&gt;按奇偶排序数组 II&lt;/a&gt;:
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。&lt;/p&gt;

&lt;p&gt;对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。&lt;/p&gt;

&lt;p&gt;你可以返回任何满足上述条件的数组作为答案。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
  &lt;li&gt;A.length % 2 == 0&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(A) {
    let len = A.length;
    let oArr = A.filter(val =&amp;gt; (val % 2 !== 0));
    let eArr = A.filter(val =&amp;gt; (val % 2 === 0));
    
    let result = [];
    for(let i = 0; i &amp;lt; len; i++) {
        if(i % 2 === 0) {
            result.push(eArr.shift());
        } else {
            result.push(oArr.shift());
        }
    }
    
    return result;
    
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;java容易理解的解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public static int[] sortArrayByParityII(int[] arr) {
        int len = arr.length;
        if(arr.length &amp;lt; 2) {
            return arr;
        }
        int odd = 1;
        int even = 0;

        while(odd &amp;lt; len &amp;amp;&amp;amp; even &amp;lt; len) {
            while(odd &amp;lt; len &amp;amp;&amp;amp; arr[odd] % 2 != 0){
                odd += 2;
            }

            while(even &amp;lt; len &amp;amp;&amp;amp; arr[even] % 2 == 0){
                even += 2;
            }

            if(odd &amp;lt; len &amp;amp;&amp;amp; even &amp;lt; len) {
                swap(arr, odd, even);
            }
        }
    }

    private static void swap(int[] arr, int odd, int even) {
        int tmp = arr[odd];
        arr[odd] = arr[even];
        arr[even] = tmp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;p&gt;js双指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
var sortArrayByParityII = function(A) { 
    let len = A.length,
        i = 0,
        j = 1;

    for(; i &amp;lt; len; i += 2) {
        if(A[i] % 2 === 0) continue;
        while(A[j] % 2 === 1);j += 2;

        [A[i], A[j]] = [A[j], A[i]];
    }
    return A;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6单值二叉树&quot;&gt;6.单值二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/univalued-binary-tree/&quot;&gt;单值二叉树&lt;/a&gt;:
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。&lt;/p&gt;

&lt;p&gt;只有给定的树是单值二叉树时，才返回 true；否则返回 false。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给定树的节点数范围是 [1, 100]。&lt;/li&gt;
  &lt;li&gt;每个节点的值都是整数，范围为 [0, 99] 。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[1,1,1,1,1,null,1]
输出：true
示例 2：

输入：[2,2,2,5,2]
输出：false

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;

&lt;p&gt;更优雅&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if(root == null) return true;
        return helper(root, root.val);
    }

    private boolean helper(TreeNode root, int val) {
        if(root == null) return true;
        if(val != root.val) return false;
        return helper(root.left, val) &amp;amp;&amp;amp; helper(root.right, val);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    boolean flag = true;
    public boolean isUnivalTree(TreeNode root) {
        if(root == null) {
            return false;
        }
        IsUnivalTree(root, root.val);
        return flag;
    }

    public void IsUnivalTree(TreeNode root, int val) {
        if(root == null) return;
        if(root.val == val) {
            IsunivalTree(root.left, val);
            IsunivalTree(root.right, val);
        } else {
            flag = false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isUnivalTree = function(root) {
    if(root == null) return true;
    return helper(root, root.val);
};

var helper = function(root, val) {
    if(root == null) return true;
    if(root.val !== val) return false;
    return helper(root.left, val) &amp;amp;&amp;amp; helper(root.right, val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7找出给定方程的正整数解&quot;&gt;7.找出给定方程的正整数解~~~&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/&quot;&gt;找出给定方程的正整数解&lt;/a&gt;:
给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。&lt;/p&gt;

&lt;p&gt;给定函数是严格单调的，也就是说：&lt;/p&gt;

&lt;p&gt;f(x, y) &amp;lt; f(x + 1, y)&lt;/p&gt;

&lt;p&gt;f(x, y) &amp;lt; f(x, y + 1)
函数接口定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。  &lt;/p&gt;

&lt;p&gt;你可以将满足条件的 结果数对 按任意顺序返回。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= function_id &amp;lt;= 9&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= z &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;题目保证 f(x, y) == z 的解处于 1 &amp;lt;= x, y &amp;lt;= 1000 的范围内。&lt;/li&gt;
  &lt;li&gt;在 1 &amp;lt;= x, y &amp;lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
示例 1：

输入：function_id = 1, z = 5
输出：[[1,4],[2,3],[3,2],[4,1]]
解释：function_id = 1 表示 f(x, y) = x + y
示例 2：

输入：function_id = 2, z = 5
输出：[[1,5],[5,1]]
解释：function_id = 2 表示 f(x, y) = x * y

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析:题目没有看懂,但是可以读懂代码&lt;/p&gt;

&lt;p&gt;双层循环&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 *
 * };
 */
/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */

var findSolution = function(customfunction, z) {
    let res = [];
    for(let x = 1; x &amp;lt;= 1000; x++) {
        for(let y = 1; y &amp;lt;= 1000; y++) {
            if(customfunction.f(x, y) &amp;gt; z) {
                break;
            }
            else if(customfunction.f(x, y) === z) {
                let ans = [x, y];
                res.push(ans);
            }
        }   
    }
    return res;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * // This is the CustomFunction's API interface.
 * // You should not implement it, or speculate about its implementation
 * function CustomFunction() {
 *
 *     @param {integer, integer} x, y
 *     @return {integer}
 *     this.f = function(x, y) {
 *         ...
 *     };
 *
 * };
 */
/**
 * @param {CustomFunction} customfunction
 * @param {integer} z
 * @return {integer[][]}
 */

var findSolution = function(customfunction, z) {
    let res = [];
    let x = 1;
    let y = 1000;
    while(x &amp;gt; 0 &amp;amp;&amp;amp; x &amp;lt;= 1000 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt;= 1000) {
        if(customfunction.f(x, y) === z) {
            let ans = [x ,y];
            res.push(ans);
            x++;
        } else if(customfunction.f(x, y) &amp;gt; z) {
            y--;
        } else {
            x++;
        }
    }
    return res;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8excel表列序号&quot;&gt;8.Excel表列序号&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/excel-sheet-column-number/submissions/&quot;&gt;Excel表列序号&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;给定一个Excel表格中的列名称，返回其相应的列序号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如，

    A -&amp;gt; 1
    B -&amp;gt; 2
    C -&amp;gt; 3
    ...
    Z -&amp;gt; 26
    AA -&amp;gt; 27
    AB -&amp;gt; 28 
    ...
示例 1:

输入: &quot;A&quot;
输出: 1
示例 2:

输入: &quot;AB&quot;
输出: 28
示例 3:

输入: &quot;ZY&quot;
输出: 701
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    let arr = s.split(&quot;&quot;);
    let len = arr.length;
    let i = 1;
    let sum = 0;
    while(i &amp;lt;= len) {
        let num = arr.pop();
        let cur = num.charCodeAt() - 64;
        sum += cur * Math.pow(26, i - 1);
        i++;
    }
    return sum;

};
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版四)</title><link href="/leetcode/2019/09/07/leetcode-four/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版四)" /><published>2019-09-07T00:00:00+08:00</published><updated>2019-09-07T00:00:00+08:00</updated><id>/leetcode/2019/09/07/leetcode-four</id><content type="html" xml:base="/leetcode/2019/09/07/leetcode-four/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1反转字符串中的单词-iii&quot;&gt;1.反转字符串中的单词 III&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/submissions/&quot;&gt;反转字符串中的单词 III&lt;/a&gt;：
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;

&lt;p&gt;注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: &quot;Let's take LeetCode contest&quot;
输出: &quot;s'teL ekat edoCteeL tsetnoc&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    return (s.split(' ').map(val =&amp;gt; val.split('').reverse().join(''))).join(' ');
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案二&quot;&gt;答案二&lt;/h4&gt;

&lt;p&gt;稍微有点取巧的做法，reverse函数也可以用双指针实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution 
{
    public String reverseWords(String s) 
    {
        String[] sp=s.split(&quot; &quot;);
        StringBuilder sb=new StringBuilder();
        for(int i=0;i&amp;lt;=sp.length-1;i++)
        {
            StringBuilder t=new StringBuilder();
            t.append(sp[i]);
            sb.append(t.reverse().toString()).append(&quot; &quot;);
        }
        return sb.substring(0,sb.length()-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2反转字符串&quot;&gt;2.反转字符串&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-string/&quot;&gt;反转字符串&lt;/a&gt;:
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;

&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;

&lt;p&gt;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;reverse&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    return s.reverse();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;其实本题并不是想考reverse, 感觉应该是想考reverse的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    var len = s.length;
    for(var i = 0, center = Math.floor(len / 2); i &amp;lt; center; i++) {
        let edx = len - i - 1;
        let temp = s[edx];
        s[edx] = s[i];
        s[i] = temp;
    }
    return s;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3数组拆分-i&quot;&gt;3.数组拆分 I&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/array-partition-i/&quot;&gt;数组拆分 I&lt;/a&gt;:
给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。&lt;/p&gt;

&lt;p&gt;提示:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;n 是正整数,范围在 [1, 10000].&lt;/li&gt;
  &lt;li&gt;数组中的元素范围在 [-10000, 10000].&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
示例 1:

输入: [1,4,3,2]

输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;首先排序 ,然后将index为奇数的进行求和.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    let sortNums = nums.sort((a, b) =&amp;gt; a - b);
    let sum = 0;
    sortNums.forEach(function(val, key) {
      if(key % 2 === 0)  {
          sum += val;
      }
    });
    
    return sum;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4键盘行&quot;&gt;4.键盘行&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/keyboard-row/&quot;&gt;键盘行&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/keyboard.png&quot; alt=&quot;&quot; /&gt;
注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;你可以重复使用键盘上同一字符。&lt;/li&gt;
  &lt;li&gt;你可以假设输入的字符串将只包含字母。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]
输出: [&quot;Alaska&quot;, &quot;Dad&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 定好map对应关系 两层遍历就可以,可以先取到首字母的指然后判断是否跟首字母相等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
    let alObj = {
        q: 0,w: 0,e: 0,r: 0, t: 0,y: 0,u: 0,i: 0,q: 0,o: 0,p: 0,
        a: 1,s: 1,d: 1,f: 1,g: 1,h: 1,j: 1,k: 1,l: 1,
        z: 2,x: 2,c: 2,v: 2,b: 2,n: 2,m: 2
    };
    
    let lWords = words.map(val =&amp;gt; val.toLowerCase());
    let leng = lWords.length;
    
    let result = [];
    
    lWords.forEach((str, key) =&amp;gt; {
        let flag = true;    
        let first =  alObj[str.charAt(0)];
        for(let i = 0; i &amp;lt; str.length; i++) {
            let current = alObj[str.charAt(i)];
            if(first !== current) {
                flag = false;
                break;
            }
        }
        if(flag) {
            result.push(words[key]);
        }
    });
    
    return result;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;正则表达式匹配&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var findWords = function(words) {
    let reg1 = new RegExp(&quot;[qwertyuiop]&quot;, &quot;i&quot;);
    let reg2 = new RegExp(&quot;[asdfghjkl]&quot;, &quot;i&quot;);
    let reg3 = new RegExp(&quot;[zxcvbnm]&quot;, &quot;i&quot;);
    let result = [];
    words.forEach(word =&amp;gt; {
        let flag1 = reg1.test(word);
        let flag2 = reg2.test(word);
        let flag3 = reg3.test(word);
        
        if((flag1 &amp;amp;&amp;amp; !flag2 &amp;amp;&amp;amp; !flag3)||(!flag1 &amp;amp;&amp;amp; !flag2 &amp;amp;&amp;amp; flag3)||(!flag1 &amp;amp;&amp;amp; flag2 &amp;amp;&amp;amp; !flag3)){
            result.push(word);
        }
    })

    return result;
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public String[] findWords(String[] workds) {
        if(words == null) {
            return null;
        }

        List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();

        String[] lines = new String[] {
            &quot;qwertyuiop&quot;,
            &quot;asdfghjkl&quot;,
            &quot;zxcvbnm&quot;
        }

        for(String word: words) {
            if(judge(word.toLowerCase(), lines)) {
                ans.add(word);
            }
        }

        return ans.toArray(new String[ans.size()]);
    }


    private boolean judge(String word, String[] lines) {
        boolean ok = true;
        String find = null;

        for(String line: lines) {
            if(line.indexOf(word.charAt(0)) &amp;gt; -1) {
                find = line;
                break;
            }
        }

        if(find == null) {
            ok = false;
            return ok;
        }

        for(ini i = 1; i &amp;lt; word.length; i++) {
            if(find.indexOf(word.charAt(i)) &amp;lt; 0) {
                ok = false;
                break;
            }
        }
        return ok;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5猜数字&quot;&gt;5.猜数字&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/guess-numbers/&quot;&gt;猜数字&lt;/a&gt;:
小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？
输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。&lt;/p&gt;

&lt;p&gt;限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;guess的长度 = 3&lt;/li&gt;
  &lt;li&gt;answer的长度 = 3&lt;/li&gt;
  &lt;li&gt;guess的元素取值为 {1, 2, 3} 之一。&lt;/li&gt;
  &lt;li&gt;answer的元素取值为 {1, 2, 3} 之一。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：guess = [1,2,3], answer = [1,2,3]
输出：3
解释：小A 每次都猜对了。
 

示例 2：

输入：guess = [2,2,3], answer = [3,2,1]
输出：1
解释：小A 只猜对了第二次。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} guess
 * @param {number[]} answer
 * @return {number}
 */
var game = function(guess, answer) {
    return guess.filter((val, key) =&amp;gt; {
        return val === answer[key];
    }).length;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int game(int[] guess, int[] answer) {
        int count = 0;
        for(int i = 0; i &amp;lt; 3; i++) {
            if(guess[i] == answer[i]) {
                counter++;
            }
        }
        return count;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6删列造序&quot;&gt;6.删列造序&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&quot;&gt;删列造序&lt;/a&gt;:
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。&lt;/p&gt;

&lt;p&gt;删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。&lt;/p&gt;

&lt;p&gt;比如，有 A = [“abcdef”, “uvwxyz”]，
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/944_1.png&quot; alt=&quot;&quot; /&gt;
要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/944_2.png&quot; alt=&quot;&quot; /&gt;
你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= A[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[&quot;cba&quot;, &quot;daf&quot;, &quot;ghi&quot;]
输出：1
解释：
当选择 D = {1}，删除后 A 的列为：[&quot;c&quot;,&quot;d&quot;,&quot;g&quot;] 和 [&quot;a&quot;,&quot;f&quot;,&quot;i&quot;]，均为非降序排列。
若选择 D = {}，那么 A 的列 [&quot;b&quot;,&quot;a&quot;,&quot;h&quot;] 就不是非降序排列了。
示例 2：

输入：[&quot;a&quot;, &quot;b&quot;]
输出：0
解释：D = {}
示例 3：

输入：[&quot;zyx&quot;, &quot;wvu&quot;, &quot;tsr&quot;]
输出：3
解释：D = {0, 1, 2}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 按照题意来说只要满足每一列的字母 b &amp;gt; a 就需要将结果加一.这里使用&lt;code&gt;charCodeAt()&lt;/code&gt;比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string[]} A
 * @return {number}
 */
var minDeletionSize = function(A) {
    let len = A.length;
    let leng = A[0].length;
    let result = 0;
    
    for(let j = 0; j &amp;lt; leng; j++) {
        for(let i = 0; i &amp;lt; len - 1; i++) { 
            let prev = A[i].charCodeAt(j);
            let next = A[i+1].charCodeAt(j);
            if(prev &amp;gt; next) {
                result++;
                break;
            }
        }
    }
    return result;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-4&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;跟js解法是一样的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int minDeletionSize(String[] A) {
        int ans = 0;
        for (int c = 0; c &amp;lt; A[0].length(); ++c)
            for (int r = 0; r &amp;lt; A.length - 1; ++r)
                if (A[r].charAt(c) &amp;gt; A[r+1].charAt(c)) {
                    ans++;
                    break;
                }

        return ans;
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7n叉树的最大深度&quot;&gt;7.N叉树的最大深度&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/&quot;&gt; N叉树的最大深度&lt;/a&gt;:
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。&lt;/p&gt;

&lt;p&gt;例如,给定一个&lt;code&gt;3叉树&lt;/code&gt; :
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们应返回最大深度,3.&lt;/p&gt;

&lt;p&gt;说明:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;树的深度不会超过 1000。&lt;/li&gt;
  &lt;li&gt;树的节点总不会超过 5000。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;因为java和JavaScript的解法一样这里我就算做一种.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
/**
 * @param {Node} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) {
        return 0;
    }
    if(root.children &amp;amp;&amp;amp; root.children.length &amp;gt; 0) {
        let max = 0;
        for(let i = 0, len = root.children.length; i&amp;lt; len; i++) {
            max = Math.max(maxDepth(root.children[i]), max)
        }
        return max + 1;
    } else {
        return 1;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int maxDeepth(Node node) {
        if(root == null) return 0;
        int max = 0;
        for(int i = 0; i &amp;lt; root.children.size(); i++) {
            max = Math.max(maxDeepth(root.children.get(i)), max);
        }
        return max + 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8-超过经理收入的员工&quot;&gt;8. 超过经理收入的员工&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/&quot;&gt;超过经理收入的员工&lt;/a&gt;: 
Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。&lt;/p&gt;

&lt;p&gt;给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+


+----------+
| Employee |
+----------+
| Joe      |
+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;
SELECT 
    a.Name AS Employee
FROM Employee AS a,
     Employee AS b
WHERE 
    a.ManagerId = b.Id
    AND a.Salary &amp;gt; b.Salary

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SELECT 
    a.Name AS Employee
FROM 
    Employee AS a 
JOIN 
    Employee AS b
ON a.ManagerId = b.Id
    AND a.Salary &amp;gt; b.Salary
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9最小差值-i&quot;&gt;9.最小差值 I&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/smallest-range-i/&quot;&gt;最小差值 I&lt;/a&gt;
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K &amp;lt;= x &amp;lt;= K，并将 x 加到 A[i] 中。&lt;/p&gt;

&lt;p&gt;在此过程之后，我们得到一些数组 B。&lt;/p&gt;

&lt;p&gt;返回 B 的最大值和 B 的最小值之间可能存在的最小差值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= K &amp;lt;= 10000&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：A = [1], K = 0
输出：0
解释：B = [1]

示例 2：

输入：A = [0,10], K = 2
输出：6
解释：B = [2,8]

示例 3：

输入：A = [1,3,6], K = 3
输出：0
解释：B = [3,3,3] 或 B = [4,4,4]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析: 这道题目乍一看不容易理解, 其实是这样的我随机从-K到K之间取值保证数组A的最大和最小值的差值最小,也就是说取得最大的最小值和最小的最大值.
那么首先要进行排序从小到大进行排序,然后取出数组A的最小值和最大值,便利K进行求和,再找出其中差值的最小值.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var smallestRangeI = function(A, K) {    
    // 从小到大排序
    A = A.sort((a, b) =&amp;gt; (a - b));
    let len = A.length;
    
    let Af = A[0];
    let Al = A[len - 1];
    
    let M = [];
    for(let i = -K; i &amp;lt;= K; i++) {
        M.push([
            Af + i,
            Al + i
        ]);
        
    }
    let klen = K - (-K) + 1;
    let delNum = M[0][1] - M[klen-1][0];
    return delNum &amp;lt;= 0 ? 0 : delNum;

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后来看了题解发现本题解的还是不够清晰,这里copy一下题解分析来得到答案二&lt;/p&gt;

&lt;h4 id=&quot;答案二-5&quot;&gt;答案二&lt;/h4&gt;

&lt;p&gt;假设 A 是原始数组，B 是修改后的数组，我们需要最小化 max(B) - min(B)，也就是分别最小化 max(B) 和最大化 min(B)。&lt;/p&gt;

&lt;p&gt;max(B) 最小可能为 max(A) - K，因为 max(A) 不可能再变得更小。同样，min(B) 最大可能为 min(A) + K。所以结果 max(B) - min(B) 至少为 ans = (max(A) - K) - (min(A) + K)。&lt;/p&gt;

&lt;p&gt;我们可以用一下修改方式获得结果（如果 ans &amp;gt;= 0）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 A[i]≤min(A)+K，那么 B[i]=min(A)+K&lt;/li&gt;
  &lt;li&gt;如果 A[i]≥max(A)−K，那么 B[i]=max(A)−K&lt;/li&gt;
  &lt;li&gt;否则 B[i]=A[i]。
如果 ans &amp;lt; 0，最终结果会有 ans = 0，同样利用上面的修改方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int smallestRangeI(int[] A, int K) {
        let min = A[0], max = A[0];
        for(int x : A) {
            min = Math.min(min, x);
            max = Math.max(max, x);
        }
        return Math.max(0, max - min - 2*K);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10将有序数组转换为二叉搜索树未完成&quot;&gt;10.将有序数组转换为二叉搜索树&lt;code&gt;未完成&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/&quot;&gt;将有序数组转换为二叉搜索树&lt;/a&gt;:
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;

&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; class Solution {
     public TreeNode sortedArrayToBST(int[] nums) {
         return sortedArrayToBST(nums, 0, nums.length);
     }

     private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
         if(start == end) {
             return null;
         }

         int mid = (start + end) &amp;gt;&amp;gt;&amp;gt; 1;
         TreeNode root = new TreeNode(nums[mid]);
         root.left = sortedArrayToBST(nums, start, mid);
         root.right = sortedArrayToBST(nums, mid + 1, end);

        return root;
     }
 }
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版三)</title><link href="/leetcode/2019/09/05/leetcode-three/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版三)" /><published>2019-09-05T00:00:00+08:00</published><updated>2019-09-05T00:00:00+08:00</updated><id>/leetcode/2019/09/05/leetcode-three</id><content type="html" xml:base="/leetcode/2019/09/05/leetcode-three/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1自除数&quot;&gt;1.自除数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/self-dividing-numbers/&quot;&gt;自除数&lt;/a&gt;：
自除数 是指可以被它包含的每一位数除尽的数。
例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
还有，自除数不允许包含 0 。
给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个输入参数的边界满足 1 &amp;lt;= left &amp;lt;= right &amp;lt;= 10000。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入： 
上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析： 关键点就是对数字进行拆分取整数和取余数,我自己的解法代码有点复杂冗余，下面是根据题解的优化方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function (left, right) {
    let arr = [];
    for(let i = left; i &amp;lt;= right; i++) {
        let n = i;
        let flag = true;
        while(n) {
            if (i % (n % 10) === 0) {
                n = Math.floor(n / 10);
            } else {
                flag = false;
                break;
            }
        }
        if(flag) {
            arr.push(i);
        }
    }
    return arr;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2二叉搜索树中的搜索&quot;&gt;2.二叉搜索树中的搜索&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-a-binary-search-tree/&quot;&gt;二叉搜索树中的搜索&lt;/a&gt;:
给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
例如，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2
你应该返回如下子树:

      2     
     / \   
    1   3
在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function(root, val) {
    if(root === null) {
        return null;
    }
    
    if(root.val &amp;gt; val) {
        return searchBST(root.left, val);
    } else if(root.val === val) {
        return root;
    } else {
        return searchBST(root.right, val);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 迭代
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root != null) {
            if(root.val == val) {
                return root;
            } else if(root.val &amp;gt; val) {
                root = root.left;
            } else {
                root = root.right;
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//按照逻辑递归
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) 
            return null;
        
        if(root.val == val) {
            return root;
        } else if(val &amp;lt; root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3n叉树的后序遍历&quot;&gt;3.N叉树的后序遍历&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/&quot;&gt;N叉树的后序遍历&lt;/a&gt;:给定一个 N 叉树，返回其节点值的后序遍历。&lt;/p&gt;

&lt;p&gt;例如，给定一个 3叉树 :
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png&quot; alt=&quot;&quot; /&gt;
返回其后序遍历: [5,6,3,2,4,1].&lt;/p&gt;

&lt;p&gt;说明: 递归法很简单，你可以使用迭代法完成此题吗?&lt;/p&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
/**
 * 第一种方式：递归
 * @param {Node} root
 * @return {number[]}
 */
var postorder = function(root) {
    if(!root) return [];

    var res = [];
    recusion(root);
    return res;

    function recusion(root) {
        if(!root) return;

        for(var i = 0; i &amp;lt; root.children.length; i++) {
            recusion(root.children[i]);
        }
        res.push(root.val);
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * 第二种方式：迭代
 * @param {Node} root
 * @return {number[]}
 */
var postorder2 = function(root) {
    if(!root) return [];
    var res = [], arr = [root];
    while(arr.length) {
        var current = arr.pop();
        for(var i = 0; i &amp;lt; current.children.length; i++) {
            arr.push(current.children[i]);
        }
        res.unshift(current.val);
    }
    return res;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;答案三-1&quot;&gt;答案三&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; postorder(Node root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;();
        if(root == null) return res;
        for(Node cur: root.children) {
            res.addAll(postorder(cur));
        }
        res.add(root.val);
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4n叉树的前序遍历&quot;&gt;4.N叉树的前序遍历&lt;/h3&gt;
&lt;p&gt;例如，给定一个 3叉树 :
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/narytree.png&quot; alt=&quot;&quot; /&gt;
返回其前序遍历: [1,3,5,6,2,4]。
说明: 递归法很简单，你可以使用迭代法完成此题吗?&lt;/p&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */
/**
 * @param {Node} root
 * @return {number[]}
 */
var preorder = function(root) {
    if(!root) return [];
    var res = [];
    recusion(root);
    return res;
    
    function recusion(root) {
        if(!root) return;
        res.push(root.val);
        for(var i = 0; i &amp;lt; root.children.length; i++) {
            recusion(root.children[i]);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; preorder(Node root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;();
        if(root == null) return res;
        res.add(root.val);
        for(Node cur: root.children) {
            res.addAll(preorder(cur));
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案三-2&quot;&gt;答案三&lt;/h4&gt;
&lt;p&gt;迭代&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public List&amp;lt;Integer&amp;gt; preorder(Node root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;();
        if(root == null) return res;
    
        Stack&amp;lt;Node&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        stack.push(root);
        while(!stack.isEmpty()) {
            Node cur = stack.pop();
            res.add(cur.val);

            List&amp;lt;Node&amp;gt; nodeList = cur.children;
            for(int i = nodeList.size() - 1; i &amp;gt;= 0; i--) {
                stack.push(nodeList.get(i));
            }
        }

        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5nim-游戏&quot;&gt;5.Nim 游戏&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/nim-game/submissions/&quot;&gt;Nim 游戏&lt;/a&gt;:
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析:随机拿1-3块石头，这里的4是一个临界点，依次以，5，6，7，8举例计算，发现每次能被4整除时一定会返回false,其他返回true&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return n % 4 ? true: false;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6山脉数组的峰顶索引&quot;&gt;6.山脉数组的峰顶索引&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/&quot;&gt;山脉数组的峰顶索引&lt;/a&gt;:
我们把符合下列属性的数组 A 称作山脉：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A.length &amp;gt;= 3&lt;/li&gt;
  &lt;li&gt;存在 0 &amp;lt; i &amp;lt; A.length - 1 使得A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个确定为山脉的数组，返回任何满足 A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1] 的 i 的值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;3 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;0 &amp;lt;= A[i] &amp;lt;= 10^6&lt;/li&gt;
  &lt;li&gt;A 是如上定义的山脉&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[0,1,0]
输出：1
示例 2：

输入：[0,2,1,0]
输出：1
 


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：通过读题其实是返回数组中最大值的索引&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} A
 * @return {number}
 */
var peakIndexInMountainArray = function(A) {
    return A.findIndex(val =&amp;gt; val == Math.max(...A));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;后台的解题方法更多可以参考一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 打桩法，也叫单向扫描，代码如下：时间复杂度为O(n)，效率略低，但是此方法具有普适性，也就是说这个方法可适用于在一般数组中找最大值。
class Solution {
    public int peakIndexInMountainArray(int[] a) {
        if(A == null || A,length &amp;lt; 3) {
            return 0;
        }

        int max = Integer.MIN_VALUE;
        int ans = 0;
        for(int i = 0; i &amp;lt; A.length; i++) {
            if(A[i] &amp;gt; max) {
                max = A[i];
                ans = i;
            }
        }
        return ans;
    }
}

// 双指针，也叫双向扫描，左右两边同时向中间扫描，以找出最大值，这个算法其实是在打桩法之上的一个效率优化，
// 时间复杂度为O(n/2)---&amp;gt;O(n)，效率较低，但比打桩法效率高，同时也具有普适性。
class Solution {
    public int peakIndexInMountainArray(int[] A) {
        if(A == null || A,length &amp;lt; 3) {
            return 0;
        }
        int max = Integer.MIN_VALUE;
        int ans = 0;

        int left = 0;
        int right = A.length - 1;

        while(left &amp;lt; right) {
            if(left &amp;lt;= right &amp;amp;&amp;amp; A[left] &amp;gt; max) {
                max = A[left];
                ans = left;
            }
            if(left &amp;lt;= right &amp;amp;&amp;amp; A[right] &amp;gt; max) {
                max = A[right];
                ans = right;
            }
            left++;
            right--;
        }

        return ans;
    }
}

// 分治法，二分查找，是适用于此题的最佳解法，时间复杂度为O(logn)，优点是效率高，缺点是不具有普适性。因为此题数组特殊，所以可用这种方法提高查找效率。
class Solution {
    public int peakIndexInMountainArray(int[] A) {
         if (A == null || A.length &amp;lt; 3)  {
            return 0;
        }
        
        int ans = 0;
    
        int left = 0;
        int right = A.length;

        while(left &amp;lt; right) {
            int center = (left + right) / 2;
            if(A[center] &amp;gt; A[center - 1] &amp;amp;&amp;amp; A[center] &amp;gt; A[center + 1]) {
                ans = center;
                break;
            } else if(A[center] &amp;lt; A[center - 1]) {
                right = center;
            } else {
                left = center;
            }
        }
        return ans;

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7除数博弈&quot;&gt;7.除数博弈&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divisor-game/&quot;&gt;除数博弈&lt;/a&gt;:
爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。
最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;选出任一 x，满足 0 &amp;lt; x &amp;lt; N 且 N % x == 0 。&lt;/li&gt;
  &lt;li&gt;用 N - x 替换黑板上的数字 N 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果玩家无法执行这些操作，就会输掉游戏。
只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。&lt;/p&gt;

&lt;p&gt;提示： 1 &amp;lt;= N &amp;lt;= 1000&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。


示例 2：

输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：自己按照题解给出的答案。但是有更简单的解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number} N
 * @return {boolean}
 */
var divisorGame = function(N) {    
    let x = finx(N);
    let oN = N;
    let count = 0;
    while(x) {
        oN = oN - x;
        x = finx(oN);
        count++;
    }
    if(count&amp;amp;1) {
        return true;
    }
    return false;
    
    function finx(num){
        let x = false;
        for(let i = 1; i &amp;lt; num; i++) {
            if(num % i === 0) {
                x = i;
                break;
            }
        }
        return x;
    }
        
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-4&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;对于这种博弈类的题目，如果没有思路的话我们不妨多举几个例子，尝试着从中找寻规律。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;假设 N = 1，爱丽丝没得选择，直接失败，即 鲍勃获胜；&lt;/li&gt;
  &lt;li&gt;假设 N = 2，爱丽丝有选择，她可以选择 x = 1，鲍勃面对的就是 N = 2 - 1 = 1，无法操作，爱丽丝获胜；&lt;/li&gt;
  &lt;li&gt;假设 N = 3，爱丽丝只能选择 x = 1，因为选 x = 2 不满足 3 % 2 = 0，鲍勃面对的就是 N = 3 - 1 = 2，参考上面 N = 2 的情形，此时鲍勃为 N = 2 的先手，鲍勃获胜；&lt;/li&gt;
  &lt;li&gt;假设 N = 4，爱丽丝可以选择 x = 1 来使鲍勃遇到 N = 3 的情况，爱丽丝获胜；
貌似有个规律：N 为奇数时， 鲍勃获胜；N 为偶数时， 爱丽丝获胜。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是这样吗？是的。&lt;/p&gt;

&lt;p&gt;事实上，无论 N 为多大，最终都是在 N = 2 这个临界点结束的。谁最后面对的是 N = 2 的情形，谁就能获胜（这句话不太理解的话，仔细看看 N = 2、N = 3 这两种情形）。
接下来，我们得知道一个数学小知识：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。
千万不要忽略 1 也是因子！&lt;/p&gt;

&lt;p&gt;爱丽丝是游戏开始时的先手。&lt;/p&gt;

&lt;p&gt;当她面对的 N 为偶数时，她 一定可以 选到一个 N 的奇数因子 x（比如 1 ），将 N - x 这个奇数传给鲍勃；用 N - x 替换黑板上的数字 N ，鲍勃面对的就是奇数 N，只能选择 N 的奇数因子 x，奇数 - 奇数 = 偶数，此时传给爱丽丝的又是偶数。这样轮换下去爱丽丝会遇到 N = 2 的情形，然后获胜；
当爱丽丝遇到的 N 是奇数时，只能传给鲍勃偶数或无法操作 (N = 1) ，无法获胜。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public boolean divisorGame(int N) {
        return N % 2 == 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8最近的请求次数代码比题目易懂&quot;&gt;8.最近的请求次数(代码比题目易懂)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-recent-calls/&quot;&gt;最近的请求次数&lt;/a&gt;:
写一个 &lt;code&gt;RecentCounter&lt;/code&gt; 类来计算最近的请求。
它只有一个方法：&lt;code&gt;ping(int t)&lt;/code&gt;，其中 t 代表以毫秒为单位的某个时间。
返回从 &lt;code&gt;3000&lt;/code&gt; 毫秒前到现在的 &lt;code&gt;ping&lt;/code&gt; 数。
任何处于 &lt;code&gt;[t - 3000, t]&lt;/code&gt; 时间范围之内的 &lt;code&gt;ping&lt;/code&gt; 都将会被计算在内，包括当前（指 t 时刻）的 &lt;code&gt;ping&lt;/code&gt;。
保证每次对 &lt;code&gt;ping&lt;/code&gt; 的调用都使用比之前更大的 t 值。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个测试用例最多调用 10000 次 ping。&lt;/li&gt;
  &lt;li&gt;每个测试用例会使用严格递增的 t 值来调用 ping。&lt;/li&gt;
  &lt;li&gt;每次调用 ping 都有 1 &amp;lt;= t &amp;lt;= 10^9。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs = [[],[1],[100],[3001],[3002]]
输出：[null,1,2,3,3]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：说实话这道题目不容易理解，配上示例也完全不知道在说啥，先看一下题解进行一下分析，题目其实是这样的
示例解读：分别在1,100,3001,3002ms发出了请求（ping）&lt;/p&gt;

&lt;p&gt;1ms时计算1ms以及1ms之前3000ms的请求数为‘1’(1ms时的ping)&lt;/p&gt;

&lt;p&gt;100ms时计算100ms以及100ms之前3000s的请求数为‘2’（1ms时的ping和100ms时的ping）&lt;/p&gt;

&lt;p&gt;3001ms时计算3001ms以及3001ms之前3000s的请求数为‘3’(1ms时的ping、100ms时的ping和3001ms时的ping)&lt;/p&gt;

&lt;p&gt;3002ms时计算3002ms以及3002ms之前3000s的请求数为‘3’(100ms时的ping、3001ms时的ping和3002ms时的ping)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var RecentCounter = function() {
    this.result = [];
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.result.push(t);
    while(this.result[0] &amp;lt; (t - 3000)) {
        this.result.shift();
    }
    return this.result.length;
};

/** 
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-5&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;官方题解：我们只会考虑最近 3000 毫秒到现在的 ping 数，因此我们可以使用队列存储这些 ping 的记录。当收到一个时间 t 的 ping 时，我们将它加入队列，并且将所有在时间 t - 3000 之前的 ping 移出队列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class RecentCounter {
    Queue&amp;lt;Integer&amp;gt; q;

    public RecentCounter() {
        q = new LinkedList();
    }

    public int ping(int t) {
        q.add(t);
        while(q.peek() &amp;lt; t - 3000) {
            q.poll();
        }
        return q.size();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9数字的补数&quot;&gt;9.数字的补数&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-complement/&quot;&gt;数字的补数&lt;/a&gt;:
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。&lt;/p&gt;

&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给定的整数保证在32位带符号整数的范围内。&lt;/li&gt;
  &lt;li&gt;你可以假定二进制数不包含前导零位。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: 5
输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。
示例 2:

输入: 1
输出: 0
解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
  let b = num.toString(2);
  let res = '';
  for(let i = 0; i &amp;lt; b.length; i++) {
      res += (Number(b.charAt(i))^1 + '');
  }

  return parseInt(res, 2);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10按奇偶排序数组&quot;&gt;10.按奇偶排序数组&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-array-by-parity/submissions/&quot;&gt;按奇偶排序数组&lt;/a&gt;:
给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
你可以返回满足此条件的任何数组作为答案。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;1 &amp;lt;= A.length &amp;lt;= 5000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;0 &amp;lt;= A[i] &amp;lt;= 5000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(A) {
  
  return A.filter(val =&amp;gt; val % 2 == 0).concat(A.filter(val =&amp;gt; val % 2 !== 0))
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-6&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int[] sortArrayByParity(int[] A) {
        int[] res = new int[A.length];
        int min = 0, max = A.length - 1;

        for(int i : A) {
            if(i % 2 == 0) {
                res[min++] = i;
            } else {
                res[max--] = i;
            }
        }

        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版二)</title><link href="/leetcode/2019/09/04/leetcode-two/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版二)" /><published>2019-09-04T00:00:00+08:00</published><updated>2019-09-04T00:00:00+08:00</updated><id>/leetcode/2019/09/04/leetcode-two</id><content type="html" xml:base="/leetcode/2019/09/04/leetcode-two/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1有趣的电影&quot;&gt;1.有趣的电影&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/not-boring-movies/&quot;&gt;有趣的电影&lt;/a&gt;：
某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。
作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如，下表 cinema:

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
对于上面的例子，则正确的输出是为：

+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;我们可以使用 mod(id,2)=1 来确定奇数 id，然后添加 description != ‘boring’ 来解决问题。
官方题解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-MySQL&quot;&gt;select * 
from cinema
where mod(id,2) != 0 and description != 'boring'
order by rating desc
;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二：&lt;/h4&gt;
&lt;p&gt;如何确定奇数除了使用mod函数还有一个比较巧妙的方法， id&amp;amp;1按位与,该操作会将数字转为32位的二进制进行比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//id=1
0001
0001

0001 结果为1

//id=2
0010
0001 

0000 结果为0

//id=3
0011
0001

0001 结果为1

//id=4
0010
0001

0000 结果为0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为1的前31位都是0，跟0进行与操作肯定是0，主要在于最后一位如果是奇数肯定能得到1，如果是0肯定是0
所以答案也可以写成这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * 
from cinema 
where description&amp;lt;&amp;gt;'boring' and id&amp;amp;1 
order by rating desc
;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2汉明距离&quot;&gt;2.汉明距离&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/hamming-distance/&quot;&gt;汉明距离&lt;/a&gt;:
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
注意：
0 ≤ x, y &amp;lt; 231.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-1&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析其实本题的意图就是将x，y转为二进制后，记录对应位置值不相同的位置数量， 所以我们就想到了按位异或。x^y后得到一个数值，需要将这个值转为二进制再去统计数量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
  let z = x^y;
  let num = 0;
  let bin = z.toString(2);
  for(let i = 0; i &amp;lt; bin.length; i++) {
      if(bin.charAt(i) === '1') {
          num++;
      }
  }
    
    return num;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3翻转二叉树&quot;&gt;3.翻转二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/invert-binary-tree/&quot;&gt;翻转二叉树&lt;/a&gt;:
翻转一棵二叉树。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {
            return null;
        }
        
        TreeNode right = invertTree(root.right);
        TreeNode left = invertTree(root.left);
        
        root.left = right;
        root.right = left;
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(root !== null) {
        [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]
    }
    return root;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4机器人能否返回原点&quot;&gt;4.机器人能否返回原点&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/robot-return-to-origin/&quot;&gt;机器人能否返回原点&lt;/a&gt;：
在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。
移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。
注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1:

输入: &quot;UD&quot;
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
示例 2:

输入: &quot;LL&quot;
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：是否回到原点，取决于上下移动的步数相等，左右移动的步数相等。
所以最简单的方法就是去计数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
     let u = 0;
        let d = 0;
        let r = 0;
        let l = 0;
        let movesArr = moves.split(&quot;&quot;);
        
        movesArr.forEach(function(val) {
            if(val === 'U') {
                u++;
            }
            if(val === 'D') {
                d++;
            }
            if(val === 'L') {
                l++;
            }
            if(val === 'R') {
                r++;
            }
            
        });
        return u === d &amp;amp;&amp;amp; r === l;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;比第一个方法要巧妙一些，不去计数了但是还是要判断步数相等，通过切割关键点来得到数组，如果关键点数量一样数组的长度相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
  return moves.split('L').length === moves.split('R').length &amp;amp;&amp;amp; moves.split('U').length === moves.split('D').length
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5高度检查器&quot;&gt;5.高度检查器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/height-checker/&quot;&gt;高度检查器&lt;/a&gt;:
学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。
请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= heights.length &amp;lt;= 100&lt;/li&gt;
  &lt;li&gt;1 &amp;lt;= heights[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例：

输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：将数组重新排序后得到新的数组去判断同一个位置的值是否相等，不想等计数+1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[]} heights
 * @return {number}
 */
var heightChecker = function(heights) {    
    var temp = heights.concat().sort((a, b) =&amp;gt; (a - b) );
    var count = 0;

    for(var i = 0; i &amp;lt; heights.length; i++) {
        if(heights[i] != temp[i]) {
            count++;   
        }
    }
    
    return count;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6二叉树的最大深度&quot;&gt;6.二叉树的最大深度&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/&quot;&gt;二叉树的最大深度&lt;/a&gt;:
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(root == null) {
        return 0;
    } else {
        let left = maxDepth(root.left);
        let right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7交换工资&quot;&gt;7.交换工资&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-salary/&quot;&gt;交换工资&lt;/a&gt;
给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。
注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

例如：

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
运行你所编写的更新语句之后，将会得到以下表:

| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;UPDATE salary 
SET sex = CASE sex
        WHEN 'm' THEN 'f'
        ELSE 'm'
    END;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8有序数组的平方&quot;&gt;8.有序数组的平方&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/squares-of-a-sorted-array/&quot;&gt;有序数组的平方&lt;/a&gt;:
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/p&gt;

&lt;p&gt;提示：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;-10000 &amp;lt;= A[i] &amp;lt;= 10000&lt;/li&gt;
  &lt;li&gt;A 已按非递减顺序排序。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
示例 2：

输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：因为是从小打大，其中可以包含负数，所以取平方后两头应该最大。之所以使用&lt;code&gt;unshift&lt;/code&gt;是因为双向指针来获取，拿到的一开始的值肯定是最大的后面越来越小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortedSquares = function(A) {
    let count = A.length;
    let result = [];
    let i = 0;
    let j = count -1;
    
    while(i &amp;lt;= j) {
        let left = Math.pow(A[i], 2);
        let right = Math.pow(A[j], 2);
        
        if(left &amp;gt; right) {
            result.unshift(left);
            i++;
        } else {
            result.unshift(right);
            j--;
        }
        
    }

    return result;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9增减字符串匹配&quot;&gt;9.增减字符串匹配&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/di-string-match/&quot;&gt;增减字符串匹配&lt;/a&gt;:
给定只含 ”I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。
返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：
如果 S[i] == “I”，那么 A[i] &amp;lt; A[i+1]
如果 S[i] == “D”，那么 A[i] &amp;gt; A[i+1]&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;示例 1：

输出：&quot;IDID&quot;
输出：[0,4,1,3,2]
示例 2：

输出：&quot;III&quot;
输出：[0,1,2,3]
示例 3：

输出：&quot;DDI&quot;
输出：[3,2,0,1]

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：根据结果的分析是所有的I从0开始依次递增，所有D从N开始依次递减&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
/**
 * @param {string} S
 * @return {number[]}
 */
var diStringMatch = function(S) {
    let len = S.length;
    let imin = 0, dmax = len;
    let result = new Array(len + 1);
    for(let i = 0; i &amp;lt;= len; i++) {
        if(S.charAt(i) === 'I') {
            result[i] = imin;
            imin++;
        } else {
            result[i] = dmax;
            dmax--;
        }
    }
    
    return result;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;分析：乍一看这个一行的解法不是特别明白，但是分析示例答案可以看出无论给出的字符串是什么样的最后都可以补充一位，可以补I也可以补D,对于结果是没有影响的
所以先不补位置。然后逢I加一 逢D减一。
var diStringMatch = function(S) {
    let a = 0,b = S.length;
    return (S+S[S.length - 1]).split('').map((x) =&amp;gt; x=='I'?a++:b--)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10组合两个表&quot;&gt;10.组合两个表&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combine-two-tables/&quot;&gt;组合两个表&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;表1: Person

+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键


表2: Address

+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键


编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
FirstName, LastName, City, State
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;因为表 Address 中的 personId 是表 Person 的外关键字，所以我们可以连接这两个表来获取一个人的地址信息。
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId
;
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">LeetCode刷题总结(简单版一)</title><link href="/leetcode/2019/09/03/leetcode-one/" rel="alternate" type="text/html" title="LeetCode刷题总结(简单版一)" /><published>2019-09-03T00:00:00+08:00</published><updated>2019-09-03T00:00:00+08:00</updated><id>/leetcode/2019/09/03/leetcode-one</id><content type="html" xml:base="/leetcode/2019/09/03/leetcode-one/">&lt;p&gt;本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。&lt;/p&gt;

&lt;h3 id=&quot;1宝石与石头&quot;&gt;1.宝石与石头&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jewels-and-stones/&quot;&gt;宝石与石头&lt;/a&gt;：
给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1:
输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;
输出: 3

示例1:
输入: J = &quot;z&quot;, S = &quot;ZZ&quot;
输出: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意:
S 和 J 最多含有50个字母。
J 中的字符不重复。&lt;/p&gt;

&lt;h4 id=&quot;答案一&quot;&gt;答案一：&lt;/h4&gt;
&lt;p&gt;分析：最笨的方法肯定是双层遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    var jLen = J.length;
    var sLen = S.length;
    var sum = 0;
    for(var i = 0; i &amp;lt; jLen; i++) {
        var j = J.charAt(i);
        for(var k = 0; k &amp;lt; sLen; k++) {
            if(j === S.charAt(k)) {
                sum++;
            }
        }   
    }
    
    return sum;
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二&quot;&gt;答案二：&lt;/h4&gt;
&lt;p&gt;通过题解得到了另一种思路就是将J进行循环遍历然后将S中的匹配值全部替换为空，这样长度的差值就是宝石的数量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    var jLen = J.length,
        sLen = S.length;
        var news= S;
    for(var i = 0; i &amp;lt; jLen; i++) {
        news = news.replace(new RegExp(J.charAt(i), 'g'), &quot;&quot;);
    }
    
    return sLen - news.length;
    
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2ip地址无效化&quot;&gt;2.IP地址无效化&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/defanging-an-ip-address/&quot;&gt;IP地址无效化&lt;/a&gt;：
给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1:
输入：address = &quot;1.1.1.1&quot;
输出：&quot;1[.]1[.]1[.]1&quot;

示例2:
输入：address = &quot;255.100.50.0&quot;
输出：&quot;255[.]100[.]50[.]0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-1&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：最简单直接的方案就是正则表达式替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} address
 * @return {string}
 */
var defangIPaddr = function(address) {
    return address.replace(/\./g, '[.]');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3删除链表中的节点&quot;&gt;3.删除链表中的节点&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-node-in-a-linked-list/&quot;&gt;删除链表中的节点&lt;/a&gt;:
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 – head = [4,5,1,9]，它可以表示为:
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/237_example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例1
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.

示例2
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;链表至少包含两个节点。&lt;/li&gt;
  &lt;li&gt;链表中所有节点的值都是唯一的。&lt;/li&gt;
  &lt;li&gt;给定的节点为非末尾节点并且一定是链表中的一个有效节点。&lt;/li&gt;
  &lt;li&gt;不要从你的函数中返回任何结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-2&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：说实话这道题目对于前端的同学来说其实很难理解。但是对于后台同学这个就太简单了，首先要理解&lt;a href=&quot;https://blog.csdn.net/jianyuerensheng/article/details/51200274&quot;&gt;单向链表的概念&lt;/a&gt;。对于本题只需要将删除后的节点指向新节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void deleteNode(ListNode node) {
    node.val = node.next.val;
    node.next = node.next.next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-1&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;对于使用javascript的版本需要首先定义一个单向链表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};

var deleteNode = function(node) {
  node = Object.assign(node, node.next)
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4查找重复的电子邮箱&quot;&gt;4.查找重复的电子邮箱&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/duplicate-emails/&quot;&gt;查找重复的电子邮箱&lt;/a&gt;: 编写一个 SQL 查询，查找 &lt;code&gt;Person&lt;/code&gt; 表中所有重复的电子邮箱。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例：
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+

返回结果：
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-3&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select Email
from Person
group by Email
having count(Email) &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-2&quot;&gt;答案二&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;select Email from
(
    select Email, count(Email) as num
    from Person
    group by Email
) as statistic
where num &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5大的国家&quot;&gt;5.大的国家&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/big-countries/&quot;&gt;大的国家&lt;/a&gt;:这里有张 World 表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。&lt;/p&gt;

&lt;p&gt;编写一个SQL查询，输出表中所有大国家的名称、人口和面积。&lt;/p&gt;

&lt;p&gt;例如，根据上表，我们应该输出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案一-4&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SELECT name, population, area 
FROM world 
WHERE area &amp;gt; 3000000
UNION
SELECT name, population, area 
FROM world 
WHERE population &amp;gt; 25000000


SELECT name, population, area 
FROM world 
WHERE area &amp;gt; 3000000 OR population &amp;gt; 25000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6二叉搜索树的范围和&quot;&gt;6.二叉搜索树的范围和&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/range-sum-of-bst/&quot;&gt;二叉搜索树的范围和&lt;/a&gt;: 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。
二叉搜索树保证具有唯一的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例1:
输入：root = [10,5,15,3,7,null,18], L = 7, R = 15
输出：32

示例2:
输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10
输出：23
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;树中的结点数量最多为 10000 个。&lt;/li&gt;
  &lt;li&gt;最终的答案保证小于 2^31。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-5&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java官方解法&lt;/code&gt;
要理解这道题首先要知道一个概念&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&quot;&gt;二叉查找树&lt;/a&gt;, 也称为二叉搜索树、有序二叉树、排序二叉树，指一棵空树或具有以下性质的二叉树：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；&lt;/li&gt;
  &lt;li&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；&lt;/li&gt;
  &lt;li&gt;任意节点的左、右子树也分别为二叉查找树；&lt;/li&gt;
  &lt;li&gt;没有键值相等的节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;深度优先搜索我们对树进行深度优先搜索，对于当前节点 node，如果 node.val 小于等于 L，那么只需要继续搜索它的右子树；如果 node.val 大于等于 R，那么只需要继续搜索它的左子树；如果 node.val 在区间 (L, R) 中，则需要搜索它的所有子树。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//深度优先搜索
class Solution {
    int ans;
    public int rangeSumBST(TreeNode root, int L, int R) {
        ans = 0;
        dfs(root, L, R);
        return ans;
    }

    public void dfs(TreeNode node, int L, int R) {
        if (node != null) {
            if (L &amp;lt;= node.val &amp;amp;&amp;amp; node.val &amp;lt;= R)
                ans += node.val;
            if (L &amp;lt; node.val)
                dfs(node.left, L, R);
            if (node.val &amp;lt; R)
                dfs(node.right, L, R);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//迭代实现深度优先搜索
class Solution {
    public int rangeSumBST(TreeNode root, int L, int R) {
        int ans = 0;
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node != null) {
                if(L &amp;lt;= node.val &amp;amp;&amp;amp; node.val &amp;lt;= R)
                    ans += node.val;

                if(L &amp;lt; node.val)
                    stack.push(node.left);
                
                if(node.val &amp;lt; R)
                    stack.push(node.right);
            }
        }

        return ans;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-3&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;画图解题
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/leetcode/tree.jpeg&quot; alt=&quot;&quot; /&gt;
假设L= 7，R=15&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果node.val &amp;gt;= 7 &amp;amp;&amp;amp; node.val &amp;lt;= 15 则直接求和&lt;/li&gt;
  &lt;li&gt;如果node.val &amp;gt; 7,则node.right的值都大于7，右侧没有搜索必要，去查找left的值&lt;/li&gt;
  &lt;li&gt;如果node.val &amp;lt; 15,则node.left的值都小于15，左侧没有搜索必要，去查找right的值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} L
 * @param {number} R
 * @return {number}
 */
var rangeSumBST = function(root, L, R) {
    var sum = 0;
        
    const dealBinTree = node =&amp;gt; {
        if(node !== null) {
            if(L &amp;lt; node.val) {
                    dealBinTree(node.left);
            }
            if(node.val &amp;gt;= L &amp;amp;&amp;amp; node.val &amp;lt;= R) {
                sum += node.val;
            }
            if(R &amp;gt; node.val) {
                    dealBinTree(node.right);
            }
            
        }
    
    }
    
    dealBinTree(root);
    
    return sum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7转换成小写字母&quot;&gt;7.转换成小写字母&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/to-lower-case/&quot;&gt;转换成小写字母&lt;/a&gt;:实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例 1：

输入: &quot;Hello&quot;
输出: &quot;hello&quot;
示例 2：

输入: &quot;here&quot;
输出: &quot;here&quot;
示例 3：

输入: &quot;LOVELY&quot;
输出: &quot;lovely&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-6&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析通过字符串的 &lt;code&gt;charCodeAt&lt;/code&gt;和&lt;code&gt;String.fromCharCode&lt;/code&gt;这两个方法来得到答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param {string} str
 * @return {string}
 */
var toLowerCase = function(str) {
    var s = '';
    for(var i = 0, len = str.length; i &amp;lt; len; i++) {
        var c = str.charCodeAt(i);
        if(c &amp;gt;= 65 &amp;amp;&amp;amp; c &amp;lt;= 90) {
           s += String.fromCharCode(c+32); 
        }  else {
           s += str.charAt(i);    
        }
        
    }
    return s;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8唯一摩尔斯密码词&quot;&gt;8.唯一摩尔斯密码词&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-morse-code-words/&quot;&gt;唯一摩尔斯密码词&lt;/a&gt;
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。
为了方便，所有26个英文字母对应摩尔斯密码表如下：&lt;/p&gt;

&lt;p&gt;[”.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”–.”,”….”,”..”,”.—”,”-.-“,”.-..”,”–”,”-.”,”—”,”.–.”,”–.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.–”,”-..-“,”-.–”,”–..”]&lt;/p&gt;

&lt;p&gt;给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。&lt;/p&gt;

&lt;p&gt;返回我们可以获得所有词不同单词翻译的数量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如:
输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]
输出: 2
解释: 
各单词翻译如下:
&quot;gin&quot; -&amp;gt; &quot;--...-.&quot;
&quot;zen&quot; -&amp;gt; &quot;--...-.&quot;
&quot;gig&quot; -&amp;gt; &quot;--...--.&quot;
&quot;msg&quot; -&amp;gt; &quot;--...--.&quot;

共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单词列表words 的长度不会超过 100。&lt;/li&gt;
  &lt;li&gt;每个单词 words[i]的长度范围为 [1, 12]。&lt;/li&gt;
  &lt;li&gt;每个单词 words[i]只包含小写字母。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;答案一-7&quot;&gt;答案一&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {string[]} words
 * @return {number}
 */
var uniqueMorseRepresentations = function(words) {
    var map = [&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;];
    
    var obj = {};

    for(var i = 0, len = words.length; i &amp;lt; len; i++) {
        
        let m = '';
        for(var j = 0, jen = words[i].length; j &amp;lt; jen; j++) {
             m += map[words[i].charCodeAt(j) - 97];
        }
        
        if(obj.hasOwnProperty(m)) {
            obj[m] = obj[m] + 1;
        } else {
            obj[m] = 1;
        }
        
    }
    

    return Object.keys(obj).length;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案二-4&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;利用Set自动去重&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] s={&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;};

        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        int index;
        for(int i = 0; i &amp;lt; words.length; i++) {
            String temp = &quot;&quot;;
            for(int j = 0; j &amp;lt; words[i].length(); j++) {
                index = (int)words[i].charAt(j) - 65 - 32;
                temp = temp.concat(s[index]);
            }
            set.add(temp);
        }
        return set.size();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9合并二叉树&quot;&gt;9.合并二叉树&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-binary-trees/&quot;&gt;合并二叉树&lt;/a&gt;:给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-8&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public TreeNode meregeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null) {
            return t2;
        }
        if(t2 == null) {
            return t1;
        }

        TreeNode result = new TreeNode(t1.val + t2.val);
        result.left = mergeTrees(t1.left, t2.left);
        result.right = mergeTrees(t1.right, t2.right);
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-5&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} t1
 * @param {TreeNode} t2
 * @return {TreeNode}
 */
var mergeTrees = function(t1, t2) {
    if(t1 === null) {
        return t2;
    }
    if(t2 === null) {
        return t1;
    }
    
    t1.val = t1.val + t2.val;
    t1.left = mergeTrees(t1.left, t2.left);
    t1.right = mergeTrees(t1.right, t2.right);
    
    return t1;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10翻转图像&quot;&gt;10.翻转图像&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flipping-an-image/&quot;&gt;翻转图像&lt;/a&gt;给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。
水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。
反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
示例 2:

输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
说明:

1 &amp;lt;= A.length = A[0].length &amp;lt;= 20
0 &amp;lt;= A[i][j] &amp;lt;= 1

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案一-9&quot;&gt;答案一&lt;/h4&gt;
&lt;p&gt;分析：最简单的方法就是按部就班来实现，先进行水平再进行图片反转。
对于1和0的翻转有两种方式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 - 当前值 得到的是1和0的翻转&lt;/li&gt;
  &lt;li&gt;1 ^ 当前值 得到的也是0和1的反转。这个符号是异或，相同为0，相异为1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    for(let i = 0, len = A.length; i &amp;lt; len; i++) {
        let re = A[i].join('');
        let im = '';
        for(let j = 0; j &amp;lt; re.length; j++) {
               im += Number(re[j]) === 0 ? '1' : '0';
        }
        A[i] = im.split('').reverse();
        
    }
    return A;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;答案二-6&quot;&gt;答案二&lt;/h4&gt;
&lt;p&gt;数组api一行解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    return A.map(val =&amp;gt; val.reverse().map(v =&amp;gt; (1 - v)))
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;答案三&quot;&gt;答案三&lt;/h4&gt;
&lt;p&gt;双向指针&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    let Alen = A.length;
    let len = A[0].length;
    for(let i = 0; i &amp;lt; Alen; i++) {
        let left = 0;
        let right = len - 1;
        while(left &amp;lt;= right) {
            let temp = A[i][left];
            A[i][left] = A[i][right] ^ 1;
            A[i][right] = temp ^ 1;
            
            left++;
            right--;
        }
    }
    return A;
};
&lt;/code&gt;&lt;/pre&gt;</content><author><name>toshiba</name></author><category term="面试" /><category term="基础" /><category term="LeetCode" /><summary type="html">本文将LeetCode刷过的题目进行简单的总结和记录，便于自己进行复习，同时将看到的解题思路进行汇总让其他的小伙伴能够理解。</summary></entry><entry><title type="html">搭建门户网站技术选型</title><link href="/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www/" rel="alternate" type="text/html" title="搭建门户网站技术选型" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www</id><content type="html" xml:base="/%E8%84%9A%E6%89%8B%E6%9E%B6/2018/10/21/scaffold-front-www/">&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;工作多年，项目越来越多，总是要做一些重复性的工作开进行开发，每次东配置西配置一大堆，效率很低无法直接投入生产。
通过这篇文章梳理一下自己的知识点，将一些常用技术做一些总结归纳和复习。并且基于此开发一套模版，用于以后网站开发直接套用，不做重复性的工作（这里的网站主要针对pc）。&lt;/p&gt;

&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;从前端的角度来说，如何从零开始开发一个门户网站呢？ 首先是要有一些基础知识包括&lt;code&gt;JavaScript&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;html&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;html&lt;/code&gt;需要了解的是，语义化的标签，还有html模版。一个html应该有什么呢，我们通过一个html模版来看下&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate&quot;&gt;html5-boilerplate&lt;/a&gt;, 这是一个专业的前端模版html。 由于篇幅问题就不再这里展开大家可以去github仓库中的dist文件夹查看index.html。
我们简单介绍下其中用到的东西&lt;/p&gt;

&lt;p&gt;首先是通用的html5的头&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在HTML中，doctype是所有文档顶部所需的“ 序言“。其唯一目的是防止浏览器在呈现文档时转换成所谓的“怪异”模式; 也就是说，doctype确保浏览器尽力尝试遵循相关规范，而不是使用与某些规范不兼容的不同渲染模式。DOCTYPE用来告知 Web 浏览器页面使用了哪种 HTML 版本,只有确定了一个正确的文档类型，HTML或XHTML中的标签和层叠样式表才能生效，甚至对JavaScript脚本都会有所影响。&lt;/p&gt;

&lt;p&gt;还有这个Meta标签，如果您需要支持IE9或IE8，那么建议使用该标签， 如果支持最新的IE11或Edge则考虑删除此标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个X-UA标记允许web作者选择呈现页面的Internet Explore版本，具体解释请看&lt;a href=&quot;https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后这里还用到了&lt;a href=&quot;https://necolas.github.io/normalize.css/&quot;&gt;normalize.css&lt;/a&gt;,来消除不通浏览器之间的样式差异。
还使用了&lt;a href=&quot;https://modernizr.com/&quot;&gt;modernizr&lt;/a&gt;，来进行浏览器功能检查。
以及大家最熟悉的jQuery(如果只兼容IE9+则可以放心使用最新版本，如果需要支持IE8则需要使用2.0以下的版本)&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;css&lt;/h2&gt;
&lt;p&gt;css我们先前在模版中已经引入了&lt;a href=&quot;https://necolas.github.io/normalize.css/&quot;&gt;normalize.css&lt;/a&gt;, 其余css基础知识的获取就需要大家自行补充了，建议读一下《css权威指南》，算是css内功方面的书籍了，再就是了解css的布局包括栅格布局，flex布局， 还有更早期的双飞翼布局，圣杯布局等等。&lt;/p&gt;

&lt;p&gt;除了这些基础实战中我们通常会用到css预处理器，&lt;a href=&quot;https://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;、&lt;a href=&quot;http://lesscss.org/&quot;&gt;Less&lt;/a&gt;和&lt;a href=&quot;http://stylus-lang.com/&quot;&gt;Stylus&lt;/a&gt;. 最开始我使用的是sass，但是这个的npm包经常会被墙下载不下来，相关依赖感觉也比较重。至于选哪种看大家喜好了，我推荐使用stylus，语法自由度很高，代码非常简洁。&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;什么是最轻量的JavaScript框架,那就是&lt;a href=&quot;http://vanilla-js.com/&quot;&gt;vanilla-js&lt;/a&gt; 来自&lt;a href=&quot;https://segmentfault.com/a/1190000000355277&quot;&gt; Vanilla JS——世界上最轻量的JavaScript框架（没有之一）&lt;/a&gt;,这里是个玩笑，因为这里说的框架其实就是原生Js。
大型网站的开发还是需要依赖各种js的库或者框架。这里简单列几种，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jQuery，虽然有些人抵触，但是为了保证代码兼容性，我还是愿意引入jQuery的&lt;/li&gt;
  &lt;li&gt;Backbone， 一款轻量级的框架，不过需要配合underscore或者lodash使用&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/wycats/handlebars.js&quot;&gt;Handlebars&lt;/a&gt;, js模版用来处理html代码片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体代码可以考虑使用ES5如果这样的话需要引入&lt;a href=&quot;https://babeljs.io/&quot;&gt;babeljs&lt;/a&gt;,做转换这样就可以愉快的使用新语法了，除此之外我们的选择还有&lt;a href=&quot;https://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt;, 和&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;代码规范可以可以参考&lt;a href=&quot;https://codeburst.io/5-javascript-style-guides-including-airbnb-github-google-88cbc6b2b7aa&quot;&gt;这篇文章&lt;/a&gt;
我推荐使用其中更为广泛的&lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;Airbnb Standard&lt;/a&gt; 比&lt;a href=&quot;https://github.com/standard/standard&quot;&gt;JavaScript Standard Style&lt;/a&gt; 更多的star。&lt;/p&gt;

&lt;h2 id=&quot;搭建&quot;&gt;搭建&lt;/h2&gt;
&lt;p&gt;好了前期准备工作已经完成现在我们开始正式开始&lt;/p&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="脚手架" /><summary type="html">起因 工作多年，项目越来越多，总是要做一些重复性的工作开进行开发，每次东配置西配置一大堆，效率很低无法直接投入生产。 通过这篇文章梳理一下自己的知识点，将一些常用技术做一些总结归纳和复习。并且基于此开发一套模版，用于以后网站开发直接套用，不做重复性的工作（这里的网站主要针对pc）。</summary></entry><entry><title type="html">安卓和IOS前端页面调试</title><link href="/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview/" rel="alternate" type="text/html" title="安卓和IOS前端页面调试" /><published>2018-10-20T00:00:00+08:00</published><updated>2018-10-20T00:00:00+08:00</updated><id>/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview</id><content type="html" xml:base="/%E8%B0%83%E8%AF%95/2018/10/20/debug-webview/">&lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;

&lt;p&gt;我们通常会有这样的开发场景， 开发了一些前端页面，可能在手机浏览器打开，也可能在客户端的webview打开，对应不同的场景我们可能需要不通的手段来进行调试。
对于简单的页面我们一般可以通过chrome的开发工具来调试或者通过safari来直接对手机打开的页面直接进行调试。 但是对于复杂webview我们可能需要一些特殊手段来进行debug.&lt;/p&gt;

&lt;p&gt;在本文将总结一部分调试技巧&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法分类&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;难度&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;调试目标&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;调试效果&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;优先级&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Chrome自带模拟器&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟效果，基本能调试 UI 及标准 JS 所有问题&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;极高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;chrome://inspect&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;安卓的自带浏览器+webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真机调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spy-debugger&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有页面不管是否是webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;效果可以&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;safari开发模式&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;简单&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;手机safari的所有页面&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;真机调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;xcode的iPhone模拟器&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;较难&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;webview和手机浏览器&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;调试效果显著&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;weinre&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;所有页面不管是否是webview&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;需要注入代码效果一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;微信开发者工具&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TBS Studio&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未测试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Browsersync&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;一般&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;模拟手机&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未测试&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;抓包&quot;&gt;抓包&lt;/h2&gt;
&lt;p&gt;对于抓包有很多工具比如 mac上面有 charles，wireShark， windows上面有fiddler 等等。
我常用的一个抓包工具叫 &lt;a href=&quot;https://mitmproxy.org/&quot;&gt;mitmproxy&lt;/a&gt;, 在github已经一万多star了，使用起来比较简单。 一条命令 &lt;code&gt;mitmproxy -p 4000 --set console_mouse=false&lt;/code&gt;, 启动后 手机手动代理到 ip+端口就可以开始抓包了，对于https可能需要&lt;a href=&quot;http://mitm.it/&quot;&gt;安装证书&lt;/a&gt;.至于安装过程就不重复了，官网已有&lt;a href=&quot;https://docs.mitmproxy.org/stable/&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;charles抓包请查看&lt;a href=&quot;https://www.jianshu.com/p/fdd7c681929c&quot;&gt;这篇教程&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;安卓的webview页面&quot;&gt;安卓的webview页面&lt;/h2&gt;
&lt;p&gt;现在的安卓应用内的页面进行调试是真的方便。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先打开手机的usb调试，连接到电脑。&lt;/li&gt;
  &lt;li&gt;第二在chrome输入 &lt;code&gt;chrome://inspect/#devices&lt;/code&gt; （开发环境安卓桌面版Chrome32+ 并且 Android 系统高于 4.4）&lt;/li&gt;
  &lt;li&gt;第三 选择app中的页面进行调试即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;safari调试iphone页面&quot;&gt;safari调试iPhone页面&lt;/h2&gt;
&lt;p&gt;这种方式适合手机上面的浏览器页面
需要几步配置&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先打开电脑的safari
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Safari设置.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后打开iPhone进行设置
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/iPhone设置.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后通过电脑的safari打开进行调试
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/开启调试.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调试iphone的webview&quot;&gt;调试iPhone的webview&lt;/h2&gt;
&lt;p&gt;iPhone的webview可行的方法就是下载xcode，然后跟客户端开发借来一个xxx.app然后用模拟器打开，这样调试页面的时候可以调试各种情况下的页面，包括safari和应用内的页面。
这是目前唯一靠谱的调试方案。 还有一些 &lt;a href=&quot;https://github.com/google/ios-webkit-debug-proxy&quot;&gt;ios-webkit-debug-proxy&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter&quot;&gt;remotedebug-ios-webkit-adapter&lt;/a&gt; 类似方案， 这些方案只能够调试手机的safari 对于app中的webview就无能为力了，而且经过本人实践效果并不理想，如果只是为了调试safari那还不如直接usb连接方便快捷，而且安装过程会有很多坑，因此不推荐使用。&lt;/p&gt;

&lt;p&gt;简化方案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//打开首页
xcrun simctl openurl booted taobao://h5.m.taobao.com/guang/index.html
// 打开模拟器
open -a &quot;Simulator.app&quot; --args -CurrentDeviceUDID &quot;FCE2CFE8-64C3-4DBE-906B-B9BF4180DE49&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前提是安装了xcode， 本地需要一个sdk与测试网站进行交互方便获取app和执行本地shell命令
根据&lt;a href=&quot;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&quot;&gt;此文章&lt;/a&gt;, 后期开发一个测试环境用的本地调试网站。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&quot;&gt;http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;weinre&quot;&gt;weinre&lt;/h2&gt;

&lt;p&gt;Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装 Weinre
    &lt;pre&gt;&lt;code&gt;$ sudo npm -g install weinre
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;启动Weinre监听服务
    &lt;pre&gt;&lt;code&gt;$ weinre --boundHost 10.10.2.144 --httpPort 8090 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;使用chrome访问
&lt;a href=&quot;http://10.10.2.144:8090&quot;&gt;http://10.10.2.144:8090&lt;/a&gt;, 然后将一段 JS 脚本 &lt;script src=&quot;http://10.10.2.144:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 插入到需要调试的页面中，插入代码后手机访问调试页面。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/weinre.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到这里还不算完，因为手动插入js不够优雅，所以这里采用js脚本注入
Tools –&amp;gt; Rewrite 选中Enable Rewrite
这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 &amp;lt;/body&amp;gt; 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。
&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.darknights.cn/assets/images/in-post/debug-webview/Charles_Rewrite_Rule.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spy-debugger&quot;&gt;spy-debugger&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot;&gt;spy-debugger&lt;/a&gt;跟微信开发这工具都在weinre的基础上简化了给页面添加js的步骤，它还对HTTPS的支持&lt;/p&gt;

&lt;p&gt;安装spy-debugger
spy-debugger内部集成了&lt;a href=&quot;http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html&quot;&gt;weinre&lt;/a&gt;、&lt;a href=&quot;https://github.com/wuchangming/node-mitmproxy&quot;&gt;node-mitmproxy&lt;/a&gt;、&lt;a href=&quot;https://github.com/alibaba/anyproxy&quot;&gt;AnyProxy&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$  sudo npm install spy-debugger -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装https证书包括手机和PC。
执行启动特别酸爽&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ spy-debugger -p 8888
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tbs-studio&quot;&gt;TBS Studio&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://x5.tencent.com/guide/debug.html&quot;&gt;TBS Studio&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;微信-webview-调试&quot;&gt;微信 WebView 调试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://x5.tencent.com/tbs/guide/debug/season1.html&quot;&gt;https://x5.tencent.com/tbs/guide/debug/season1.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;browsersync&quot;&gt;browserSync&lt;/h2&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://75team.com/post/webview-debug.html&quot;&gt;前端 WebView 指南之调试篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://elevenbeans.github.io/2017/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/&quot;&gt;移动端浏览器调试方法汇总&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aotu.io/notes/2017/02/24/Mobile-debug/index.html&quot;&gt;移动端真机调试指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/riskers/blog/issues/11&quot;&gt;打造最舒适的webview调试环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yujiangshui.com/multidevice-frontend-debug/&quot;&gt;移动端前端开发调试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="工具" /><category term="调试" /><summary type="html">场景</summary></entry><entry><title type="html">你不知道的JavaScript中卷(一)</title><link href="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one/" rel="alternate" type="text/html" title="你不知道的JavaScript中卷(一)" /><published>2018-10-18T00:00:00+08:00</published><updated>2018-10-18T00:00:00+08:00</updated><id>/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one</id><content type="html" xml:base="/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/2018/10/18/read-book-you-known-middle-one/">&lt;h2 id=&quot;字符串&quot;&gt;字符串&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var a = &quot;foo&quot;;
b = [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;];

var c = Array.prototype.join.call(a, &quot;-&quot;);

var d = Array.prototype.map.call(a, function(v) {
	return v.toUpperCase() + &quot;.&quot;
}).join(&quot;&quot;);


c; // &quot;f-o-o&quot;

d; // &quot;F.O.O.&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数字&quot;&gt;数字&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var a = 5E10;

a; // 50000000000

a.toExponential(); // &quot;5e+10&quot;


// toFixed 用来显示小数部分的显示位数
var a = 42.59;

a.toFixed(0);  // &quot;43&quot;

a.toFixed(1);  // &quot;42.6&quot;

a.toFixed(2);  // &quot;42.59&quot;


42.toFixed(3); // SyntaxError 报错 42. 被视为一个整体 所以没有访问toFixed

以下访问方式都没有问题

(42).toFixed(3);  // &quot;42.000&quot;
0.42.toFixed(3);  // &quot;0.420&quot;
42..toFixed(3);   // &quot;42.000&quot;


// toPrecision 方法用来制定有效数位的显示位数

var a = 42.59;

a.toPrecision(1); // &quot;4e+1&quot;
a.toPrecision(2); // &quot;43&quot;
a.toPrecision(3); // &quot;42.6&quot;
a.toPrecision(4); // &quot;42.59&quot;
a.toPrecision(5); // &quot;42.590&quot;



&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;浮点数&quot;&gt;浮点数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;0.1 + 0.2 === 0.3; // false

由于浮点数的精读问题导致
0.1 + 0.2; // 0.3000000000000004;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果判断0.1 + 0.2 和 0.3 是否相等呢， 最常见的做法是设置一个误差范围值， 通常称为”机器精度”， 对于JavaScript来说这个值通常是2^-52;
ES6开始，该值定义在&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
if(!Number.EPSILON) {
	Number.EPSILON = Math.pow(2, -52);
}


function numbersCloseEnoughToEqual(n1, n2) {
	return Math.abs(n1 - n2) &amp;lt; Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual(a, b);  // true;

numbersCloseEnoughToEqual(0.0000001, 0.0000002); // false;


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;整数检测&quot;&gt;整数检测&lt;/h2&gt;
&lt;p&gt;要检测一个值是否是整数，可以使用ES6种的Number.isInteger方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.isInteger(42);     // true

Number.isInteger(42.00);  // true

Number.isInteger(45.3);   // false

// ES6 之前的polyfill Number.isInteger

if(!Number.isInteger) {
	Number.isInteger = function(num) {
		return typeof num == 'number' &amp;amp;&amp;amp; num % 1 == 0;
	}
}


// 最大安全数

Numbe.isSafeInteger(Number.MAX_SAFE_INTEGER); // true
Numbe.isSafeInteger(Math.pow(2, 53)); // false
Numbe.isSafeInteger(Math.pow(2, 53) - 1); // true

// ES6 之前的polyfill Number.isSafeInteger

if(!Number.isSafeInteger) {
	Number.isSafeInteger = function(num) {
		return Number.isInteger(num) &amp;amp;&amp;amp; Math.abs(num) &amp;lt;= Number.MAX_SAFE_INTEGER;
	}
}



&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;零值&quot;&gt;零值&lt;/h2&gt;
&lt;p&gt;JavaScript有一个常规的0(+0), 和一个-0
-0， 除了可以作为常量以外，也可以是某些数学运算的返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var a = 0 / -3; // -0

var b = 0 * -3; // -0

加法和减法运算不会得到负零


根据规范对于负零进行字符串化操作会返回&quot;0&quot;
var a = -0;

a.toString();
a + &quot;&quot;;
String(a);
JSON.stringify(a)

以上都会返回 &quot;0&quot;, 但是返回来将其从字符串转换为数字，得到的结果是准确的

+&quot;-0&quot;;            // -0
Number(&quot;-0&quot;);     // -0
JSON.parse(&quot;-0&quot;); // -0


0 === -0; // true

0 == -0;  // true

0 &amp;gt; -0;    // false

判断是否是 -0

function isNegZero(n) {
	n = Number(n);

	return (n === 0) &amp;amp;&amp;amp; (1 / n === -Infinity);
}


isNegZero(-0);      // true
isNegZero(0 / -3);  // true
isNegZero(0);       // false

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为什么需要-0呢，有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度), 数字的符号为sign用来代表其他信息(比如移动方向),此时如果一个值为0的变量失去了它的符号位，它的方向信息就回丢失。所以保留0值的符号为可以防止这类情况发生。&lt;/p&gt;

&lt;h2 id=&quot;特殊等式&quot;&gt;特殊等式&lt;/h2&gt;
&lt;p&gt;如前所述，NaN和0在相等比较时表现有些特别，由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN或者polyfill, 而 +0 和 -0 的比较我们也需要借助于 isNegZero这样的工具函数。&lt;/p&gt;

&lt;p&gt;ES6引入了一个工具方法Object.is(…)来判断两个值是否绝对相等用来处理上面特殊情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var a = 2 / &quot;foo&quot;; 
var b = -3 * 0;

Object.is(a, NaN); // true

Object.is(b, -0);  // true

Object.is(b, 0);   // false


ES6之前的polyfill

if(!Object.is) {
	Object.is = function(v1, v2) {
		//判断是否是-0
		if(v1 === 0 &amp;amp;&amp;amp; v2 === 0) {
			return 1 / v1 === 1 / v2;
		}

		// 判断是否是NaN
		if(v1 !== v1) {
			return v2 !== v2;
		}

		return v1 === v2;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;json字符串化&quot;&gt;JSON字符串化&lt;/h2&gt;
&lt;p&gt;对于大多数简单值来说JSON字符串化和toString效果基本相同，只不过序列化的结构总是字符串
所有安全的JSON值都呈现为有效的JSON格式的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(42);  // &quot;42&quot;
JSON.stringify(&quot;42&quot;) // &quot;&quot;42&quot;&quot;
JSON.stringify(null) // &quot;null&quot;
JSON.stringify(true) // &quot;true&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对而言不安全的JSON值包括 undefined, function , symbol和包含循环引用的对象都不符合JSON的标准结构，其他支持JSON的语言无法处理它们。&lt;/p&gt;

&lt;p&gt;JSON.toStringify(…)在处理对象中遇到undefined,function,Symbol是会自动将其忽略，在数组中则返回null，以保证单于位置不变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JSON.stringify(undefined)     			// undefined
JSON.stringify(function() {}) 		    // undefined
JSON.stringify(
	[1, undefined, function() {}, 4] 	// &quot;[1, null, null, 4]&quot;
)
JSON.stringify(
	{a: 2, b: function() {}}         	// &quot;{&quot;a&quot;: 2}&quot;
) 
JSON.stringify(undefined) // undefined

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对象定义了toJSON方法，JSON字符串化会首先调用该方法然后用它的返回值来进行序列化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {};
var a = {
	b: 42,
	c: o,
	d: function() {}
}

o.e = a;

//循环引用会报错
// JSON.stringify(a);

//自定义的JSON序列化
a.toJSON = function() {
	return {b: this.b};
}

JSON.stringify(a); // &quot;{b: 42}&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsonstringify&quot;&gt;JSON.stringify&lt;/h2&gt;
&lt;p&gt;几个不为人知的知识点,该方法可以传入一个replacer，它可以是数组或者函数，用来制定对象序列化过程中那些应该被处理，哪些应该被排除，如果replacer是一个数组，那么它必须是一个字符串数组，其中高喊序列化要处理的对象的属性名称。除此之外的其他属性被忽略。如果replacer是一个函数，它会对对象本身调用一次然后对对象中的每个属性各调用一次，每次传递两个参数key和value，如果要忽略某个key就返回undefined，否则返回指定值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = {
	b: 42,
	c: &quot;42&quot;,
	d: [1,2,3]
}

JSON.stringify(a, [&quot;b&quot;, &quot;c&quot;]); // &quot;{&quot;b&quot;: 42, &quot;c&quot;: &quot;42&quot;}&quot;

JSON.stringify(a, function(k, v) {
	if(k !== &quot;c&quot;) return v;	
});

// &quot;{&quot;b&quot;: 42, &quot;d&quot;: [1,2,3]}&quot;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON.stringify还有一个可选参数space用来指定输出的缩进格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = {
	b: 42,
	c: &quot;42&quot;,
	d: [1,2,3]
}

JSON.stringify(a, null, 3);

JSON.stringify(a, null, '---------');


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;tonumber&quot;&gt;toNumber&lt;/h2&gt;
&lt;p&gt;true转换为1，false转换为0，undefined转换为NaN，null转为0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Number(&quot;&quot;);  // 0
Number([]);  // 0
Number([&quot;abc&quot;]);  // NaN

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;奇特的运算符&quot;&gt;奇特的～运算符&lt;/h2&gt;
&lt;p&gt;字位运算只适用于32位整数，运算符将会强制操作数使用32位格式。 ToInt32首先执行ToNumber 然后执行ToInt32，虽然严格来说并非强制类型转换，但是字位运算符和一些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字
例如&lt;code&gt;|&lt;/code&gt;的空操作,会将后面转为数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 | -0;        // 0
0 | NaN;       // 0
0 | Infinity;  //0
0 | -Infinity; //0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说～ 可以理解为&lt;code&gt;-(x+1)&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;～42; // -43

~-1; // 0

var a = &quot;Hello world&quot;;

~a.indexOf(&quot;lo&quot;);  // -4

~a.indexOf(&quot;ol&quot;); // 0

if(!~a.indexOf(&quot;ol&quot;)) {
	// 无匹配
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字位截取&quot;&gt;~~字位截取&lt;/h2&gt;
&lt;p&gt;有些开发人员使用&lt;code&gt;~~&lt;/code&gt;来借去数字值的消暑部分，以为这和Math.floor的效果一样，实际上并非如此
~~它首先只适用于32位数字，更重要的是它对负数的处理和Math.floor不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.floor(-49.6); // -50  
~~-49.6;      // -49 该方法会舍弃

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;显示解析数字字符串&quot;&gt;显示解析数字字符串&lt;/h2&gt;

&lt;p&gt;parseInt是解析，允许字符串中出现非数字字符，解析从左到右遇到非数字字符就停止。而转换Number不允许出现非数字字符，否则会失败并返回NaN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = &quot;42&quot;;
var b = &quot;42px&quot;;

Number(a); // 42
parseInt(a); // 42

Number(b); // NaN
parseInt(b) // 42

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;parseInt和parseFloat是针对字符串值，所以传递其他类型的值是没有用的，他们会被强制类型转换成字符串。&lt;/p&gt;

&lt;p&gt;ES5之前的一个坑就是如果没有指定第二个参数来给定转换基数，则会以第一个参数的第一个字符来自行决定。如果第一个字符是 x 或者 X 则转换为十六进制， 如果是0则转换为八进制。&lt;/p&gt;

&lt;p&gt;如下代码如果值为08:09 ,转换后的值为0:0 因为 8 和 9 都不是有效的八进制数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
var hour = parseInt(selectHour.value);
var minute = parseInt(selectMinute.value);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将第二个参数设置为10即可避免这个问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var hour = parseInt(selectHour.value, 10);
var minute = parseInt(selectMinute.value, 10);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幸运的是从ES5开始&lt;code&gt;parseInt(...)&lt;/code&gt;默认转换为十进制， 除非另外指定。如果你的代码在ES5之前的环境运行，请记得将第二个值设置为10.&lt;/p&gt;

&lt;p&gt;有这样一个坑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(1/0, 19); // 18

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里parseInt接收字符串参数, 所以 Infinity 被转换为 “Infinity”; 19也不是一个正规的基数，所以这里其实是在转换 parseInt(“Infinity”, 19);&lt;/p&gt;

&lt;p&gt;按照十六进制表示规则 a =&amp;gt; 10, b =&amp;gt; 11, c =&amp;gt; 12, … i =&amp;gt; 18 … z =&amp;gt; 35; 基数是19所有小于19的字母都是有效数字。&lt;/p&gt;

&lt;p&gt;此外还有一些看起来奇怪但是解释的通的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这个例子 小数点后六位之前转为 0
parseInt(0.000008); // 0    
//但是小数点后七位就转为 8e-7 再转字符串&quot;8e-7&quot; 8是有效数字
parseInt(0.0000008); // 8


// &quot;fa&quot;都是有效数字 f = 15 a = 10;  15 * 16 + 10 = 250
parseInt(false, 16); // 250

//parseInt.toString()
//&quot;function parseInt() { [native code] }&quot;
//&quot;f&quot;解析位16进制的15
parseInt(parseInt, 16); // 15

//16进制的10 就是16
parseInt(&quot;0x10&quot;); // 16
// 3不是有效的二进制， 只解析 10, 2进制的10  就是十进制的2
parseInt(&quot;103&quot;, 2) // 2


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;隐式转换&quot;&gt;隐式转换&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt; 之间&lt;code&gt;==&lt;/code&gt;比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果x为null， y是undefined 结果为true&lt;/li&gt;
  &lt;li&gt;如果x为undefined， y是null 结果为true&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = null;
var b;

a == b;    // true
a == null; // true
b == null; // true

a == false; // false
b == false; // false
a == &quot;&quot;;    // false
b == &quot;&quot;;    // false
a == 0;     // false
b == 0;     // false


var a = doSomething();

if(a == null) {
	//...
}
条件判断 a == null 仅在 doSomething() 返回 null 和 undefined时才成立，除此之外其他值不成立包括0, false 和&quot;&quot;这样的假植

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象和非对象之间的比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果Type(x)是字符串或者数字， Type(y)是对象， 则返回 x == ToPrimitive(y)的结果&lt;/li&gt;
  &lt;li&gt;如果Type(x)是对象， Type(y)是字符串或者数字， 则返回 ToPrimitive(x) == y的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = 42;
var b = [42];

a == b; // true



var a = &quot;abc&quot;;
var b = Object(a);  // 和 new String(a) 一样

a == b;  // true

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是有一些值不这样， 原因是==算法中其他优先级更高的规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
var a = null;
var b = Object(a); // 和Object()一样

a == b;  // false


var c = undefined;
var d = Object(c); // 和Object一样
c == d; // false


var e = NaN;
var f = Object(e); // 和new Number(e)一样

e == f; // false

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为没有对应的封装对象所以null和undefined不能够被封装， &lt;code&gt;Object(null)&lt;/code&gt;, &lt;code&gt;Object(undefined)&lt;/code&gt;，都返回一个常规对象。NaN能被封装为数字封装对象，但是拆封之后NaN == NaN返回false， 因为NaN不等于NaN。&lt;/p&gt;

&lt;p&gt;比较少见的情况
2 == 3 不会有这种情况， new Number会调用valueOf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.prototype.valueOf = function(){
	return 3;
}

new Numebr(2) == 3; // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假值相等比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&quot;0&quot; == null;      // false
&quot;0&quot; == undefined; // false
&quot;0&quot; == false;     // true
&quot;0&quot; == NaN;       // false
&quot;0&quot; == 0;        // true
&quot;0&quot; == &quot;&quot;;       // false



false == null;      // false
false == undefined; // false
false == NaN;       // false
false == 0;        // true
false == &quot;&quot;;       // true
false == [];       // true
false == {};       // false



&quot;&quot; == null;      // false
&quot;&quot; == undefined; // false
&quot;&quot; == NaN;       // false
&quot;&quot; == 0;        // true
&quot;&quot; == [];       // true
&quot;&quot; == {};       // false


0 == null;      // false
0 == undefined; // false
0 == NaN;       // false
0 == [];       // true
0 == {};       // false


这个最好

[] == ![]  // true

2 == [2] // true
&quot;&quot; == [null] // true

0 == &quot;\n&quot;   // true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽象关系的比较&lt;/p&gt;

&lt;p&gt;双方先调用toPrimitive，如果结果出现非字符串，就根据toNumber规则将双方强制转换为数字进行比较&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = [42];
var b = &quot;43&quot;;

a &amp;lt; b; // true
b &amp;lt; a; // false

如果双方都是字符串，则按照字母顺序比较

var a = [&quot;42&quot;];
var b = [&quot;043&quot;];

a &amp;lt; b;  // false
a和b不转为数字，因为你toPrimitive返回的字符串这里比较的是&quot;42&quot; 和 &quot;043&quot;两个字符串，比较的是&quot;4&quot; 和&quot;0&quot; 


var a = [4, 2];
var b = [0, 4, 3];

a &amp;lt; b; // false  比较 &quot;4, 2&quot; 和 &quot;0, 4, 3&quot;的首字母

var a = { b: 42 };
var b = { b: 43 };

a &amp;lt; b;  // false 转为&quot;[object Object]&quot; 和&quot;[object Object]&quot;所以按照字母顺序比较并不成立


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的例子比较奇怪&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = { b: 42 };
var b = { b: 43 };

a &amp;lt; b; // false

a == b; // false

a &amp;gt; b; // false

a &amp;lt;= b; // true
a &amp;gt;= b; // true


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据规范 a &amp;lt;=b 被处理成 !(a &amp;gt; b)&lt;/p&gt;

&lt;h2 id=&quot;javascript表达式&quot;&gt;JavaScript表达式&lt;/h2&gt;
&lt;p&gt;表达式的副作用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 42;
var b = a++;

a; // 43

b; // 42


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签表达式 break; continue;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence&quot;&gt;运算符优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>toshiba</name></author><category term="javascript" /><category term="读书总结" /><summary type="html">字符串 ``` var a = “foo”; b = [“f”, “o”, “o”];</summary></entry></feed>